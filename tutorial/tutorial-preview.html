<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <meta http-equiv="Content-Type" content="application/xml; charset=UTF-8">
      <title>TUTORIAL PREVIEW</title>
      <style type="text/css">
                  .toc { font-size: 80%; padding: 0.4em; outline: thin solid black; margin: 0.4em 0em; width: fit-content;
                    counter-reset: lessonNo 0 }
                  .toc * { margin: 0em; font-weight: normal }
                  .toc div { margin: 0.2em; margin-left: 1em; outline: thin solid grey }
                  .toc .lesson { display: flex; counter-increment: lessonNo 1; padding: 0.8em }
                  .toc .lesson:nth-child(even) { background-color: lightsteelblue }
                  .toc div.lesson:before { content: attr(class) ' ' counter(lessonNo); background-color: lavender; color: midnightblue; padding: 0.2em; font-family: sans-serif
                    display: inline-block; height: fit-content }
                  .toc .unit { width: 30vw; background-color: whitesmoke }
                  section section section { margin: 0.2em; margin-left: 1em; padding-left: 0.6em; border-left: medium solid grey }
                  
                  
               </style>
   </head>
   <body>
      <div class="toc">
         <div class="lesson">
            <div class="unit">
               <h1>101: Project setup and installation</h1>
               <div>
                  <h2>Goals</h2>
               </div>
               <div>
                  <h2>Prerequisites</h2>
               </div>
               <div>
                  <h2>Resources</h2>
               </div>
               <div>
                  <h2>Step One: Setup</h2>
                  <div>
                     <h3>Shortcut</h3>
                  </div>
               </div>
               <div>
                  <h2>Step Two: Confirm</h2>
               </div>
               <div>
                  <h2>Comments / review</h2>
                  <div>
                     <h3>Tweaks</h3>
                  </div>
               </div>
            </div>
            <div class="unit">
               <h1>102: Examining the setup</h1>
               <div>
                  <h2>Goals</h2>
               </div>
               <div>
                  <h2>Resources</h2>
               </div>
               <div>
                  <h2>Prerequisites</h2>
               </div>
               <div>
                  <h2>Step One: Inspect the pipelines</h2>
               </div>
               <div>
                  <h2>Step Two: Modify the pipelines</h2>
               </div>
               <div>
                  <h2>For consideration</h2>
               </div>
            </div>
            <div class="unit">
               <h1>599: Meeting XProc</h1>
               <div>
                  <h2>Some observations</h2>
               </div>
            </div>
         </div>
         <div class="lesson">
            <div class="unit">
               <h1>101: Unpacking XProc 3.0</h1>
               <div>
                  <h2>Goals</h2>
               </div>
               <div>
                  <h2>Resources</h2>
                  <div>
                     <h3>For reference</h3>
                  </div>
               </div>
               <div>
                  <h2>Prerequisites</h2>
               </div>
               <div>
                  <h2>A closer look</h2>
               </div>
               <div>
                  <h2>Walkthrough</h2>
                  <div>
                     <h3>TEST-XPROC3</h3>
                  </div>
                  <div>
                     <h3>TEST-XSLT</h3>
                  </div>
                  <div>
                     <h3>TEST-SCHEMATRON</h3>
                  </div>
                  <div>
                     <h3>TEST-XSPEC</h3>
                  </div>
               </div>
               <div>
                  <h2>A not-so-simple pipeline</h2>
                  <div>
                     <h3>What do we see</h3>
                  </div>
               </div>
               <div>
                  <h2>XML syntax, XPath and XProc</h2>
               </div>
               <div>
                  <h2>Learning more about XProc</h2>
               </div>
            </div>
            <div class="unit">
               <h1>102: XProc fundamentals</h1>
               <div>
                  <h2>Goals</h2>
               </div>
               <div>
                  <h2>Resources</h2>
               </div>
               <div>
                  <h2>Prerequisites</h2>
               </div>
               <div>
                  <h2>Learning more about XProc</h2>
               </div>
               <div>
                  <h2>Details details!</h2>
                  <div>
                     <h3>TEST-XSPEC</h3>
                  </div>
                  <div>
                     <h3>PRODUCE-TUTORIAL-ELEMENTLIST.xpl</h3>
                  </div>
               </div>
               <div>
                  <h2>Messing around</h2>
                  <div>
                     <h3>Disabling your code</h3>
                  </div>
               </div>
               <div>
                  <h2>Take note</h2>
                  <div>
                     <h3>Where are these downloads coming from?</h3>
                  </div>
                  <div>
                     <h3>Syntax tips</h3>
                  </div>
               </div>
            </div>
            <div class="unit">
               <h1>599: More context</h1>
               <div>
                  <h2>Goals</h2>
               </div>
               <div>
                  <h2>Resources</h2>
               </div>
               <div>
                  <h2>Prerequisites</h2>
               </div>
               <div>
                  <h2>XProc schema</h2>
               </div>
               <div>
                  <h2>XPath</h2>
                  <div>
                     <h3>Documents and data</h3>
                  </div>
               </div>
               <div>
                  <h2>Survey of XProc elements</h2>
               </div>
               <div>
                  <h2>XML time line</h2>
               </div>
               <div>
                  <h2>XPath illustrative examples</h2>
               </div>
               <div>
                  <h2>XML and the XDM: context and rationale</h2>
               </div>
               <div>
                  <h2>Exercise: Discussion board</h2>
               </div>
            </div>
         </div>
      </div>
      <section class="lesson"
               id="setup">
         <section class="unit"
                  id="setup_101">
            <h1>101: Project setup and installation</h1>
            <section>
               <h2>Goals</h2>
               <p>Run an XProc 3.0 pipeline in an XProc 3.0 engine. See the results.</p>
               <p>With a little practice, become comfortable running XProc pipelines, seeing results on a console (command
            line) window as well as in the file system.</p>
               <p>After the first script to get the XProc engine, we use XProc for subsequent downloads. Finishing the setup
            gets you started practicing with the pipelines.</p>
            </section>
            <section>
               <h2>Prerequisites</h2>
               <p>You have Java installed with a JVM (Java Virtual Machine) available on the command line (a JRE or JDK),
            version 8 (and later).</p>
               <p>You have a live Internet connection and the capability to download and save resources (binaries and code
            libraries) for local use.</p>
               <p>
                  <b>Tip:</b> check your Java version from the console using <code>java --version</code>.</p>
               <p>You are comfortable entering commands on the command line. For installation, you want a <code>bash</code>
            shell if available. On Windows, both WSL (Ubuntu) and Git Bash have been found to work. If you cannot use
               <code>bash</code>, the setup can be done by hand (downloading and unpacking a package from
            SourceForge).</p>
               <p>After installation, subsequent work on Windows does not require <code>bash</code> unless you choose to use
            it – a Windows <code>CMD</code> or Powershell can serve as your environment and the processor invoked with a
            Windows <code>bat</code> file (as described in the documentation). Mac and Linux (and WSL) users can
            continue to use <code>bash</code>.</p>
            </section>
            <section>
               <h2>Resources</h2>
               <p>The setup script is a <code>bash</code> script: <a href="../../../setup.sh">./setup.sh</a>, to be run with no arguments.</p>
               <p>For XProc runtime — to execute pipelines — use either of the scripts <a href="../../../xp3.sh">./xp3.sh</a> (under <code>bash</code>) or <a href="../../../xp3.bat">./xp3.bat</a> (for Windows). These scripts are
            used for all pipelines (basically, for everything) unless otherwise noted.</p>
               <p>The following pipelines will be run. They are described in top-level <a href="../../../README.md">README</a> documentation and the expected places.</p>
               <ul>
                  <li>
                     <a href="../../../lib/GRAB-SAXON.xpl">lib/GRAB-SAXON.xpl</a>
                  </li>
                  <li>
                     <a href="../../../lib/GRAB-SCHXSLT.xpl">lib/GRAB-SCHXSLT.xpl</a>
                  </li>
                  <li>
                     <a href="../../../lib/GRAB-XSPEC.xpl">lib/GRAB-XSPEC.xpl</a>
                  </li>
                  <li>
                     <a href="../../../smoketest/TEST-XPROC3.xpl">smoketest/TEST-XPROC3.xpl</a>
                  </li>
                  <li>
                     <a href="../../../smoketest/TEST-XSLT.xpl">smoketest/TEST-XSLT.xpl</a>
                  </li>
                  <li>
                     <a href="../../../smoketest/TEST-SCHEMATRON.xpl">smoketest/TEST-SCHEMATRON.xpl</a>
                  </li>
                  <li>
                     <a href="../../../smoketest/TEST-XSPEC.xpl">smoketest/TEST-XSPEC.xpl</a>
                  </li>
               </ul>
            </section>
            <section>
               <h2>Step One: Setup</h2>
               <p>Find setup instructions for the repository in the <a href="../../../README.md">Project README</a> and in the linked <a href="../../../setup-notes.md">Setup Notes</a>.</p>
               <p>After reading and reviewing these documents, perform the setup as instructed. To do this you can either
            fork or clone the repository in GitHub or simply download and decompress a zip of the <a href="https://github.com/usnistgov/oscal-xproc3/archive/refs/heads/main.zip">current
            distribution</a>.</p>
               <p>After running the setup script, or performing the installation by hand, make sure you can run all the smoke
            tests successfully.</p>
               <p>As noted in the docs, if you happen already to have <a href="https://www.xml-project.com/morganaxproc-iiise.html">Morgana XProc III</a>, you do not need to
            download it again. Try skipping straight to the smoke tests. (You can use a runtime script
               <code>xp3.sh</code> or <code>xp3.bat</code> as a model for your own, and adjust. Any reasonably recent
            version of Morgana should function if configured correctly, and we are interested if it does not.) </p>
               <section>
                  <h3>Shortcut</h3>
                  <p>If you want to run through the tutorial exercises but you are unsure of how deeply you will delve, you
               can postpone two of the installations until later:</p>
                  <ul>
                     <li>You will need XSpec only when you want to run tests of stylesheets or queries using the <a href="https://github.com/xspec/xspec">XSpec</a> testing framework</li>
                     <li>You will need SchXSLT only when you want to run Schematron (or XSpec tests of Schematron)</li>
                  </ul>
                  <p>When you see tracebacks suggesting one of these is not supported, you can return to setup.</p>
                  <p>Since almost any pipeline will use XSLT and since we do use the latest version (XSLT 3.0 with XPath 3.1), consider
               the Saxon installation an essential requirement.</p>
               </section>
            </section>
            <section>
               <h2>Step Two: Confirm</h2>
               <p>The top-level README and setup notes also describe testing your installation. Do this next.</p>
               <p>You know things are working in your XProc when either or both of two things are happening:</p>
               <ul>
                  <li>On the console, notifications show up with reassuring messages announcing progress</li>
                  <li>When you expect files to be produced, they appear, or are updated, as expected</li>
               </ul>
               <p>Both of those will occur with this lesson. The files produced by downloading scripts are written into the
            project <code>lib</code> directory, as documented. Refresh or restore by deleting the downloaded files and
            running the pipelines to acquire them again.</p>
               <p>Note: you need a live Internet connection for your http requests to go through.</p>
               <p>When you can run all the smoke tests without ugly tracebacks, this lesson is complete.</p>
            </section>
            <section>
               <h2>Comments / review</h2>
               <p>Within this project as a whole, and within its subprojects, everything is done with XProc 3.0, meaning
            everything can be done using a single script, which invokes an XProc processor to read and execute a
            pipeline. This simplicity is at the center of the argument for XProc. The counter argument is that the world
            is never like that. This project is based on the premise that a lab environment can be useful even for
            studying things more commonly encountered in the real world.</p>
               <p>Effectively (and much more could be said about the processing stack, dependency management and so forth)
            what this means is that XProc offers the user and the developer (in either or both roles) with focused and
            concentrated points of control or points of adjustment. In the field -- where software is deployed and
            used -- things almost never just <q>drop in</q>. User interfaces, APIs, dependencies and platform quirks: all these 
            constrain what users can do, and even developers are rarely free to just mess around, as it might be thought of.</p>
               <p>To the extent this is the case, this project only works if things are actually simple enough to pick up,
            use, learn and adapt.</p>
               <p>
                  <code>xp3.sh</code> and <code>xp3.bat</code> represent attempts at this. Each of them (on its execution
            platform) enables a user to run, without further configuration, the <a href="https://www.xml-project.com/morganaxproc-iiise.html">Morgana XProcIIIse</a> processor on any XProc
            3.0 pipeline, assuming the appropriate platform for each (<code>bash</code> in the case of the shell script,
            Windows batch command syntax for the <code>bat</code> file). Other platforms supporting Java (and hence
            Morgana with its libraries) could be provided with similar scripts.</p>
               <p>Such a script itself must be <q>vanilla</q> and generic: it simply invokes the processor with the designated
            pipeline, and stands back. The logic of operations is entirely encapsulated in the XProc pipeline
            designated. XProc 3.0 is both scalable and flexible enough to open a wide range of possibilities for data
            processing, both XML-based and using other formats such as JSON and plain text. It is the intent of this
            project not to explore and map this space – which is vast – but to show off enough XProc and related logic
            (XSLT, XSpec) to show how this exploration can be done. We are an outfitter at the beginning of what
            we hope will be a long and profitable voyage.</p>
               <section>
                  <h3>Tweaks</h3>
                  <p>As simple examples, these scripts show only one way of running XProc. Keep in mind that even simple
               scripts can be used in more than one way. </p>
                  <p>For example, a pipeline can be executed from the project root:</p>
                  <pre>$ ./xp3.sh smoketest/TEST-XPROC3.xpl</pre>
                  <p>Alternatively, a pipeline can be executed from its home directory, for example if currently in the
                  <code>smoketest</code> directory (note the path to the script): </p>
                  <pre>$ ../xp3.sh TEST-XPROC3.xpl</pre>
                  <p>This works the same ways on Windows, with adjustments: </p>
                  <pre>&gt; ..\xp3 TEST-XPROC3.xpl </pre>
                  <p>(On Windows a <code>bat</code> file suffix marks it as executable and does not have to be given
               explicitly when calling.)</p>
                  <p>Windows users (and others to varying degrees) can set up a drag-and-drop based workflow - using your
               mouse or pointer, select an XProc pipeline file and drag it to a shortcut for the executable (Windows
               batch file). A command window opens to show the operation of the pipeline. See the <a href="../../README.md">README</a> for more information.</p>
                  <p>It is important to try things out since any of these methods can be the basis of a workflow. </p>
                  <p>For the big picture, keep in mind that while the command line is useful for development and demonstration
               – and however familiar XProc itself may become to the developer – to the uninitiated it remains obscure
               and cryptic. XProc-based systems, when integrated into tools or developer editors and environments, can
               look much nicer than tracebacks in a console window. The beauty we are looking for here is in a different
               kind of elegance and power.</p>
               </section>
            </section>
         </section>
         <section class="unit"
                  id="setup_102">
            <h1>102: Examining the setup</h1>
            <section>
               <h2>Goals</h2>
               <ul>
                  <li>Look at some pipeline organization and syntax on the inside</li>
                  <li>Success and failure invoking XProc pipelines: an early chance to "learn to die" gracefully (to use the
               gamers' idiom).</li>
               </ul>
            </section>
            <section>
               <h2>Resources</h2>
               <p>Same as <a href="setup_101_src.html"
                     class="LessonUnit">Setup 101</a>.</p>
            </section>
            <section>
               <h2>Prerequisites</h2>
               <p>Please complete the repository setup and smoke tests as described in the <a href="setup_101_src.html"
                     class="LessonUnit">101 lesson</a>. In this lesson, we will run these pipelines with adjustments, or
            similar pipelines.</p>
               <p>This discussion assumes basic knowledge of coding, the Internet (including retrieving resources via
               <code>file</code> and <code>http</code> protocols), and web-based technologies including HTML.</p>
               <p>XML knowledge is also assumed. In particular, XProc uses <a href="https://www.w3.org/TR/xpath-31/">XPath
               3.1</a>, the query language for XML. This latest version of XPath builds on XPath 1.0, so any XPath
            experience will help. In general, any XSLT or XQuery experience will be invaluable.</p>
               <p>You will also need a programmer's plain text editor, XML/XSLT editor or IDE (integrated development
            environment) for more interactive testing of the code.</p>
            </section>
            <section>
               <h2>Step One: Inspect the pipelines</h2>
               <p>The two groupings of pipelines used in setup and testing can be considered separately.</p>
               <p>The key to understanding both groups is to know that once the initial <a href="../../../setup.sh">Setup
               script</a> is run, Morgana can be invoked directly, as paths and scripts are already in place. In doing
            so – before extension libraries are in place – it can use only basic XProc steps, but those are enough for
            these purposes.</p>
               <p>Specifically, the pipelines can acquire resources from the Internet, save them locally, and perform
            unarchiving (unzipping). Having been downloaded, each library provides software that the pipeline engine
            (Morgana) can use to do more.</p>
               <p>Accordingly, the first group of pipelines (in the <a href="../../../lib/readme.md">lib</a> directory has
            a single purpose, namely (together and separately) to download software for Morgana.</p>
               <ul>
                  <li>
                     <a href="../../../lib/GRAB-SAXON.xpl">lib/GRAB-SAXON.xpl</a>
                  </li>
                  <li>
                     <a href="../../../lib/GRAB-SCHXSLT.xpl">lib/GRAB-SCHXSLT.xpl</a>
                  </li>
                  <li>
                     <a href="../../../lib/GRAB-XSPEC.xpl">lib/GRAB-XSPEC.xpl</a>
                  </li>
               </ul>
               <p>The second group of pipelines also has a single purpose, namely to exercise and test the capabilities provided by the software downloaded by the first group.</p>
               <ul>
                  <li>
                     <a href="../../../smoketest/TEST-XPROC3.xpl">smoketest/TEST-XPROC3.xpl</a> tests MorganaXProc-III</li>
                  <li>
                     <a href="../../../smoketest/TEST-XSLT.xpl">smoketest/TEST-XSLT.xpl</a> tests Saxon</li>
                  <li>
                     <a href="../../../smoketest/TEST-SCHEMATRON.xpl">smoketest/TEST-SCHEMATRON.xpl</a> tests
               SchXSLT</li>
                  <li>
                     <a href="../../../smoketest/TEST-XSPEC.xpl">smoketest/TEST-XSPEC.xpl</a> tests XSpec</li>
               </ul>
               <p>Take a look at these. It may be helpful to envision the XML syntax as a set of nested frames with labels and
            connectors.</p>
               <p>Try more than one way of looking at the XProc source code: in the Github repository, on your file system, in
            a plain text editor, in an XML editor.</p>
            </section>
            <section>
               <h2>Step Two: Modify the pipelines</h2>
               <p>Use a text editor or software development application for this exercise.</p>
               <p>If you have any concepts for improvements to the pipelines, or other resources that might be acquired this way, copy and modify one of the pipelines given to achieve those results.</p>
               <p>Even if not - be sure to break the pipelines given -- or copies under new names -- in any of several ways.
            Then run the modified pipelines, as a <i>safe way</i> to familiarize yourself with error messages:</p>
               <ul>
                  <li>Break the XML syntax of a pipeline and try to run it</li>
                  <li>Leave XML syntax intact (well-formed), but break something in the XProc <ul>
                        <li>An element name, attribute or attribute setting</li>
                        <li>A namespace</li>
                     </ul>
                  </li>
                  <li>Try to retrieve something from a broken link</li>
               </ul>
               <p>Make sure that pipelines are back in working order when this exercise is complete.</p>
            </section>
            <section>
               <h2>For consideration</h2>
               <p>Developers coming to this technology need to consider who would use it, and whether it is useful mainly at
            the back end, or also <q>on the shop floor</q>, directly in the hands of professionals who must work with
            the data, bringing expertise in subject matter (such as, for OSCAL, systems security documentation) but not
            in data processing as such.</p>
               <p>Key to this question is not only whether attractive and capable user interfaces (or other mediators) can be
            developed (this is a known problem) but more importantly whether the systems themselves are adaptable enough
            so they can be deployed, used, refitted and maintained not just for repetitive generic tasks, but for
               <i>particular</i>, <i>special</i> and <i>local</i> problems discovered only at the points where
            information is gathered and codified.</p>
               <p>This larger fitting of solutions to problems is a responsibility for both SMEs (subject matter experts) and
            developers together, who must define problems to be solved before approaches to them can be found.</p>
               <p>The open questions are: who can use XProc pipelines; and how can they be made more useful? The questions
            come up in an OSCAL context or any context where XML is demonstrably capable.</p>
            </section>
         </section>
         <section class="unit"
                  id="setup_599">
            <h1>599: Meeting XProc</h1>
            <section>
               <h2>Some observations</h2>
               <p>Because it is now centered on <i>pipelines</i> as much as on files and software packages, dependency
            management is different from other technologies including Java and NodeJS - how so?</p>
               <p>MorganaXProc-III is implemented in Scala, and Saxon is built in Java, but otherwise distributions including
            the SchXSLT and XSpec distributions consist mainly of XSLT. This is either very good (with development and
            maintenance requirements in view), or not good at all.</p>
               <p>How much of this is due to the high-level, abstracted nature of <a href="https://en.wikipedia.org/wiki/Fourth-generation_programming_language">4GLs</a> including both XSLT
            3.1 and XProc 3.0?</p>
            </section>
         </section>
      </section>
      <section class="lesson"
               id="unpack">
         <section class="unit"
                  id="unpack_101">
            <h1>101: Unpacking XProc 3.0</h1>
            <section>
               <h2>Goals</h2>
               <ul>
                  <li>More familiarity with XProc 3.0: some syntax</li>
                  <li>Some awareness of background history, concepts and resources</li>
               </ul>
            </section>
            <section>
               <h2>Resources</h2>
               <p>This lesson discusses, in more depth, the same pipelines you ran in setup: <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 101</a>, in particular <a href="../../../smoketest/readme.md">the smoke test pipelines</a>.</p>
               <p>Also, this lesson discusses a pipeline used for producing this tutorial: <a href="../../PRODUCE-TUTORIAL-ELEMENTLIST.xpl">PRODUCE-TUTORIAL-ELEMENTLIST.xpl</a> generates an <a href="../../sequence/element-directory.md">index to XProc in this repository</a>
               </p>
               <section>
                  <h3>For reference</h3>
                  <p>The <a href="https://xproc.org">XProc.org 3.0 dashboard page</a> offers a hub for reference materials and
               community contributions.</p>
                  <p>The last section of this lesson unit describes more reference materials as well.</p>
               </section>
            </section>
            <section>
               <h2>Prerequisites</h2>
               <p>Same as <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 101</a>.</p>
            </section>
            <section>
               <h2>A closer look</h2>
               <p>If you have completed <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 102</a> you have
            already inspected the <a href="../../../lib/readme.md">lib</a> and <a href="../../../smoketest/readme.md">smoketest</a> folders, and run pipelines you have found there.</p>
               <p>Routine code inspection can also be done on Github as well (not a bad idea in any case), not just in a
            copy.</p>
               <p>A quick summary of what these pipelines do:</p>
               <ul>
                  <li>
                     <a href="../../../lib/GRAB-SAXON.xpl">lib/GRAB-SAXON.xpl</a> downloads a zip file from a <a href="https://www.saxonica.com/download">Saxonica download site</a>, saves it, and extracts a
                  <code>jar</code> (Java library) file, which it places in the Morgana library directory</li>
                  <li>
                     <a href="../../../lib/GRAB-SCHXSLT.xpl">lib/GRAB-SCHXSLT.xpl</a> downloads a zip file from Github and
               unzips it into a directory where Morgana can find it.</li>
                  <li>
                     <a href="../../../lib/GRAB-XSPEC.xpl">lib/GRAB-XSPEC.xpl</a> also downloads and <q>unarchives</q> a zip
               file resource, this time a copy of <a href="https://github.com/xspec/xspec">an XSpec
               distribution</a>.</li>
               </ul>
               <p>Essentially, these all replicate and capture the work a developer must do to identify and acquire libraries.
            Maintaining our dependencies this way - not quite, but almost <q>by hand</q> -- appears to have benefits for
            system transparency and robustness.</p>
               <p>The second group of pipelines is a bit more interesting. Each of the utilities provided for in packages just
            downloaded is tested by running a smoke test.</p>
               <p>Each smoke test performs a minor task, serving as a <q>smoke test</q> inasmuch as its only aim is to
            determine whether a simple representative process completes successfully. (When we plug in the board, can we
            see and smell smoke?)</p>
               <ul>
                  <li>
                     <a href="../../../smoketest/TEST-XPROC3.xpl">smoketest/TEST-XPROC3.xpl</a> amounts to an XProc <q>Hello
                  World</q>. In that spirit, feel free to write your own version.</li>
                  <li>
                     <a href="../../../smoketest/TEST-XSLT.xpl">smoketest/TEST-XSLT.xpl</a> tests Saxon, an XSLT/XQuery
               transformation engine. XSLT and XQuery are related technologies (different languages, same data model)
               developed with XML processing in mind, but in recent years generalized to a wider range of data
               structures.</li>
                  <li>
                     <a href="../../../smoketest/TEST-SCHEMATRON.xpl">smoketest/TEST-SCHEMATRON.xpl</a> tests SchXSLT.
               SchXSLT is an implementation of Schematron, an ISO-standard validation and reporting technology. As this
               implementation relies on XSLT, this library also requires Saxon.</li>
                  <li>
                     <a href="../../../smoketest/TEST-XSPEC.xpl">smoketest/TEST-XSPEC.xpl</a> tests XSpec, an XSLT-based
               testing framework useful for testing deployments of XSLT, XQuery and Schematron.</li>
               </ul>
               <p>Any and each of these can be used as a <q>black box</q> by any competent operator, even without
            understanding the internals. But this simplicity masks and manages complexity. XProc is XProc but its
            capabilities are limited without XSLT, XQuery, Schematron, XSpec and others, an open-ended set of compatible
            and complimentary technologies.</p>
               <p>At the same time, common foundations make it possible to learn these technologies together and in
            tandem.</p>
            </section>
            <section>
               <h2>Walkthrough</h2>
               <p>Each of the test pipelines exercises a simple sequence of operations. Open the XSpec file in an editor or
            viewer where you can see the tags.</p>
               <section>
                  <h3>TEST-XPROC3</h3>
                  <p>Examine the pipeline <a href="../../../smoketest/TEST-XPROC3.xpl">TEST-XPROC3.xpl</a>. It breaks down as
               follows:</p>
                  <ul>
                     <li>
                        <code>p:output</code> – An <em>output port</em> is defined. It specifies that when the process
                  results are delivered, a couple of serialization rules are followed: the text is indented and written
                  without an XML declaration at the top. With this port, the process outputs can be captured by the
                  calling process (such as your script), or simply echoed to the console.</li>
                     <li>
                        <code>p:identity</code> – An <em>identity step</em> does nothing with its input but simply passes it
                  along. This one is a little different from usual in that its inputs are given as literal (XML)
                  contents in the pipeline. Essentially, because this pipeline has this step, it does not need to load
                  or rely on any inputs, because its inputs are given here. The input is a single line of XML.</li>
                     <li>
                        <code>p:namespace-delete</code> – A <em>namespace-delete</em> step is used to strip an XML namespace
                  definition from the document bound to the identity step. This XML inherits namespaces from the
                  pipeline itself, but it has no elements or attributes that use it, so the namespace is unneeded and
                  its declaration comes through as noise. With this step the pipeline results are clean and simple.</li>
                  </ul>
                  <p>When you run this pipeline, the <code>CONGRATULATIONS</code> document given in line will be echoed to the
               console, where designated outputs will appear if not otherwise directed.</p>
               </section>
               <section>
                  <h3>TEST-XSLT</h3>
                  <p>
                     <a href="../../../smoketest/TEST-XSLT.xpl">This pipeline</a> executes a simple XSLT transformation, in
               order to test that XSLT transformations can be successfully executed.</p>
                  <ul>
                     <li>
                        <code>p:output</code> – An output port is designated with <code>p:output</code> as in the <a href="../../../smoketest/TEST-XPROC3.xpl">TEST-XPROC3 pipeline</a>.</li>
                     <li>
                        <code>p:xslt</code> – Instead of providing a literal document in an <em>identity</em> step, this
                  pipeline performs an XSLT transformation. The input to this transformation is given as a literal XML
                  in the same way, except this time it is provided as input to a transformation process defined by an <a href="../../../smoketest/src/congratulations.xsl">XSLT stylesheet</a> called in by the
                  pipeline.</li>
                     <li>
                        <code>p:namespace-delete</code> – The <code>ox</code> namespace is stripped from the result as in <a href="../../../smoketest/TEST-XPROC3.xpl">TEST-XPROC3 pipeline</a>. This could have been done in
                  the XSLT as well, but this way the transformation has one less thing to do or go wrong. More simpler
                  steps being better than fewer complicated ones.</li>
                  </ul>
                  <p>Like the <a href="../../../smoketest/TEST-XPROC3.xpl">TEST-XPROC3 pipeline</a> this pipeline shows its
               results in the console. This time the result is not just the XML given in the pipeline, but that XML as
               modified by the transformation.</p>
                  <p>If your pipeline execution can't process the XSLT (perhaps Saxon is not installed, or the XSLT itself has
               a problem) you will get an error to say so.</p>
                  <p>Errors in XProc are reported by the Morgana engine using XML syntax. Among other things, this means they
               can be captured and processed in pipelines.</p>
               </section>
               <section>
                  <h3>TEST-SCHEMATRON</h3>
                  <p>Schematron is a language used to specify rules to apply to XML documents. In this case a small Schematron
               is applied to a small XML.</p>
                  <ul>
                     <li>
                        <code>p:output</code> – An output port is designated for the results with the same settings.</li>
                     <li>
                        <code>p:validate-with-schematron</code> – This is an XProc step specifically for evaluating an XML
                  document against the rules of a given Schematron. Like the TEST-XPROC3 and TEST-XSLT` pipelines, this
                  one presents its own input, given as a literal XML document given in the pipeline document (using
                     <code>p:inline</code>). A setting on this step provides for it to throw an error if the document
                  does not conform to the rules. The Schematron file provided as input to this step, <a href="../../../smoketest/src/doing-well.sch">src/doing-well.sch</a>, gives the rules. This flexible
                  technology enables easy testing of XML against rule sets defined either for particular cases in
                  particular workflows, or for entire classes or sets of documents.</li>
                     <li>
                        <code>p:namespace-delete</code> – This step is used here as in the other tests for final cleanup of
                  the information produced.</li>
                  </ul>
               </section>
               <section>
                  <h3>TEST-XSPEC</h3>
                  <p>
                     <a href="https://github.com/xspec/xspec">XSpec</a> is a testing framework for XSLT, XQuery and
               Schematron. It takes the form of a vocabulary and a process (inevitably implemented in XSLT and XQuery)
               for executing queries, transformations, and validations, by running them over known inputs, comparing the
               results to expected results, and reporting the results of this comparison. XProc, built to orchestrate
               manipulations of XML contents, is well suited for running XSpec with no additional overhead.</p>
                  <p>An XSpec instance (or <q>document</q>) defines a set of tests for a transformation or query module using
               the XSpec vocabulary. An XSpec implementation executes the tests and delivers the results. Since XSpec,
               like Schematron, reports its findings in XML, XProc can be useful both to manage the inputs and outputs,
               and to process the XSpec reports.</p>
                  <ul>
                     <li>
                        <code>p:import</code> – calls to an external XProc file to make its step definitions available.</li>
                     <li>
                        <code>p:input</code> – works as it does elsewhere, to declare inputs for the pipeline. In this case,
                  the inputs must be XSpec documents using the XSpec vocabulary. You can expect errors when they are
                  not. This testing pipeline offers three different XSpecs to be run, one each for XSLT, XQuery and
                  Schematron.</li>
                     <li>
                        <code>p:for-each</code> – defines a step or sequence of steps to be applied to each input,
                  separately.</li>
                     <li>
                        <code>p:identity</code> – simply passes through the previous step's result. While this is a
                     <q>no-op</q> in the XProc itself, it provides an occasion for a message to help trace the XProc
                  execution.</li>
                  </ul>
               </section>
            </section>
            <section>
               <h2>A not-so-simple pipeline</h2>
               <p>These simple pipelines show how useful things can be done simply, while the pipeline architecture allows for
            great flexibility.</p>
               <p>Simplicity and flexibility together enable complexity. Once it is factored out, a complex operation can be
            managed and deployed just like asimple one, its internal complexities being masked by a simple and
            predictable interface.</p>
               <p>Next, take a look at a more complex example, the prototype pipeline <a href="../../PRODUCE-TUTORIAL-ELEMENTLIST.xpl">PRODUCE-TUTORIAL-ELEMENTLIST.xpl</a>. Like the setup and
            smoke-test pipelines, this is a standalone pipeline that acquires inputs and produces results and writes
            those results to the file system. The output it generates is stored as <a href="../../sequence/element-directory.md">element-directory.md</a>, a Markdown file.</p>
               <p>This result presents an index of XProc elements used in pipelines described in this tutorial. For any XProc
            element used anywhere, the listing shows the pipelines where it appears. It also shows a list of project
            folders in the order they are treated by this tutorial, showing for each one the XProc files found there
            along with whatever XProc elements appear <i>first</i> (within the tutorial sequence) within that
            pipeline.</p>
               <p>Delete or rename this result file and run the pipeline to confirm it functions properly.</p>
               <p>The Markdown file produced may be useful for finding XPoc examples in the repository. Consider also what
            other kinds of indexing might be useful. When you modify XProc or add new XProc pipelines to the project
            folders, consider running this pipeline again to update the indexes.</p>
               <p>Open the file and inspect it to get a sense of what it does. The XML syntax is verbose, but not really all
            that frightening. The pipeline is described in more detail in the <a href="unpack_102_src.html"
                     class="LessonUnit">102 Lesson unit</a> in this lesson.</p>
               <section>
                  <h3>What do we see</h3>
                  <p>There are two significant differences between this pipeline and the small ones we have looked at so
               far.</p>
                  <ul>
                     <li>Of course, it is longer and more complex, reflecting the complexity of the operations it
                  performs.</li>
                     <li>Unlike the test pipelines, this XProc has no input port, hence no documents considered as input.
                  Instead, it collects data to process by <i>reading the file system</i> and loading files directly.
                  This is especially useful here as it includes everything it finds – meaning we can extend or update
                  the index by adding files and running the pipeline again, without altering any pipeline logic.</li>
                  </ul>
               </section>
            </section>
            <section>
               <h2>XML syntax, XPath and XProc</h2>
               <p>Newcomers to XML may feel they are in the deep water with XML syntax.</p>
               <p>In the context of XProc, this is actually not as hard as it looks:</p>
               <ul>
                  <li>All XML files follow the same syntax rules with respect to tags, elements and attributes (names and
               syntax), namespaces, comments etc.</li>
                  <li>XML vocabularies are typically qualified with namespaces to show, and disambiguate, which XML
               application or language they belong to. The namespaces are indicated by name prefixes. So in this
               repository (and conventionally for XProc), any element prefixed <code>p:</code> is an XProc element, and
               another prefix or none indicates an extension or another vocabulary, such as appears in XML being
               processed.</li>
                  <li>Embedded in the syntax is another syntax, <em>XPath</em>. This lightweight but powerful query language
               is a formal subset of XQuery. XPath is ubiquitous in XProc, XSLT, Schematron, XSpec etc. In XProc, the
               XPath will ordinarily be given in attributes.</li>
                  <li>Learn more about this in the <a href="unpack_102_src.html"
                        class="LessonUnit">102 Lesson unit</a> – or
               plunge on, and pick up what you need as you go.</li>
               </ul>
            </section>
            <section>
               <h2>Learning more about XProc</h2>
               <p>This tutorial has a handmade<a href="../../xproc-links.md">XProc links page</a> with links.</p>
               <p>Also, see the official <a href="https://xproc.org">XProc.org dashboard page</a>.</p>
               <p>Also, check out XProc index materials (with code snips) produced in this repository: <a href="../../../projects/xproc-doc/readme.md">XProc docs</a>. Produced using XProc, these
            can be covered in detail in a later lesson unit.</p>
               <p>There is <a href="https://xmlpress.net/publications/xproc-3-0/">a book, Erik Siegel's <i>XProc 3.0
                  Programmer's Reference</i>
                  </a> (2020).</p>
            </section>
         </section>
         <section class="unit"
                  id="unpack_102">
            <h1>102: XProc fundamentals</h1>
            <p>
            </p>
            <section>
               <h2>Goals</h2>
               <ul>
                  <li>More familiarity with XProc 3.0, with more syntax</li>
                  <li>Get hands a little dirty – and practice washing up</li>
                  <li>First look at XProc pipeline organization</li>
               </ul>
            </section>
            <section>
               <h2>Resources</h2>
               <p>Take a quick look <i>now</i> (and a longer look later):</p>
               <p>This tutorial's handmade <a href="../../xproc-links.md">XProc links page</a>
               </p>
               <p>Also, the official <a href="https://xproc.org">XProc.org dashboard page</a>
               </p>
               <p>Also, check out XProc index materials produced in this repository: <a href="../../../projects/xproc-doc/readme.md">XProc docs</a>
               </p>
               <p>And the same pipelines you ran in setup: <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 101</a>.</p>
            </section>
            <section>
               <h2>Prerequisites</h2>
               <p>You have done <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 101</a>, <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 102</a> and <a href="unpack_101_src.html"
                     class="LessonUnit">Unpack 101</a>.</p>
            </section>
            <section>
               <h2>Learning more about XProc</h2>
               <p>A partial list of ways to learn more about XProc:</p>
               <ul>
                  <li>Search engines: use keywords <q>XProc3</q> or <q>XProc 3.0</q> to help distinguish from 1.0
               technologies</li>
                  <li>Resources: <a href="../../xproc-links.md">links</a> here and elsewhere</li>
                  <li>Hands on exercises</li>
                  <li>Work the notes - save out and annotate these pages</li>
               </ul>
            </section>
            <section>
               <h2>Details details!</h2>
               <p>XProc pipelines described in <a href="unpack_101_src.html"
                     class="LessonUnit">the previous lesson unit</a>
            contain a few noteworthy features.</p>
               <p> To edit these files, use any XML-capable plain text editor (that is, with care, any editor at all that
            saves text files as UTF-8).</p>
               <section>
                  <h3>TEST-XSPEC</h3>
                  <ul>
                     <li>Where XSpec documents are bound to the input port <code>source</code>, they have
                     <code>content-type='application/xml'</code> given. This is because with the unconventional file
                  suffix <code>xspec</code> (useful for other reasons), the XProc engine needs extra information to know
                  they should be read as XML, not some other data format. Try removing the <code>content-type</code> to </li>
                     <li>The step <code>p:for-each</code> is not just a step: it also contains steps. It is a <em>compound
                     step</em>, described further below. You would be correct to infer this step enables us to perform
                  operations on several inputs in parallel: just what this pipeline needs.</li>
                     <li>Within the <code>p:for-each</code>, the step <code>ox:execute-xspec</code> is named in the
                     <code>ox</code> namespace, which resolves to the string
                     <code>http://csrc.nist.gov/ns/oscal-xproc3</code>, a value assigned for this project. This step is
                  defined in the <a href="../../../xspec/xspec-execute.xpl">imported pipeline</a>. XProc is indefinitely
                  extensible: the namespace feature allows us to create new steps without fear of name clashes with old
                  steps – or steps that are still uninvented and unnamed. We can develop and name steps in our own
                  namespace, while also acquiring and using steps in other namespaces.</li>
                     <li>The <code>p:identity</code> step is used twice in this pipeline for one purpose only: to indicate
                  messages the XProc engine should deliver. In the normal configuration, you should see these messages
                  in the console when the pipeline runs. This is a common use for <code>p:identity</code>.</li>
                     <li>The repository observes a couple of conventions with regard to steps and messages. For example: any
                     <code>p:load</code> or <code>p:save</code> step should have a message; and messages should always
                  be prefixed with a bracketed indicator of the pipeline that issues them, for example the
                     <code>[TEST-XSPEC]</code> messages that are emitted here, once for each input and again once when
                  the pipeline finishes.</li>
                     <li>Yes, those conventions are enforced in the repository by <a href="../../../testing/xproc3-house-rules.sch">a Schematron</a> that can be applied to any
                  pipeline, both in development and when it is committed to the repository under CI/CD (continuous
                  integration / continous development). Assuming we take care to run our tests and validations, this
                  does most of the difficult work maintaining consistency, namely detecting the inconsistency.</li>
                     <li>Reassuring messages aside, no XSpec reports are actually captured by this XProc! With nothing bound
                  to an output port, it <em>sinks</em> by default. That is because it is a smoke test, and we care only
                  to see that it runs and completes without error. The inputs are all controlled, so we know what those
                  reports say. Or we can find out.</li>
                  </ul>
               </section>
               <section>
                  <h3>PRODUCE-TUTORIAL-ELEMENTLIST.xpl</h3>
                  <p>The pipeline <a href="../../PRODUCE-TUTORIAL-ELEMENTLIST.xpl">PRODUCE-TUTORIAL-ELEMENTLIST.xpl</a> has
                  <q>real-world complexity</q>. Reviewing its steps can give a sense of how XProc combines simple
               capabilities into complex operations. Notwithstanding the title of this section, it is not important to
               understand every detail – knowing they are there is enough.</p>
                  <ul>
                     <li>The prologue here contains a single <code>p:input</code> configuration. This one gives the input in
                  line, as an XML document. Within this XML, all the project folders to be covered by the index are
                  listed. Their order also matters since one of the two indexes built works incrementally, prior
                  elements affecting what happens with later elements.</li>
                  </ul>
               </section>
            </section>
            <section>
               <h2>Messing around</h2>
               <p>Taking some time to make and test small adjustments to working code is a great way to develop a sense of how
            it behaves.</p>
               <p>An easy way to do this without perturbing the working code in the repository is to copy a pipeline and
            modify the copy. Modifying one of the smoketest pipelines, see what happens when:</p>
               <ul>
                  <li>An <code>@href</code> points to a location on the system where there is no file</li>
                  <li>A file is there, but it is not what is expected (for example: XML is expected but the file is not well
               formed)</li>
                  <li>A <code>p:namespace-delete</code> step is removed from the end of a pipeline – how does the result
               change?</li>
                  <li>Other steps are excluded</li>
                  <li>New elements are renamed (etc.)</li>
               </ul>
               <p>When changes introduce errors, runtime failures and tracebacks will <i>sometimes</i> appear. The indicated
            problem or the source of the reported problem must be repaired.</p>
               <p>And sometimes a process will run successfully, despite an <q>error</q>. Whether it is in error then depends
            on how well it conforms to its requirements. Does it deliver the results we want and expect?</p>
               <p>As an exercise, make some changes in copies of the test pipelines. Make at least one change that produces
            outputs (such as echoing a document to the console) that are visibly different from the results of the
            original pipeline.</p>
               <section>
                  <h3>Disabling your code</h3>
                  <p>For newcomers to XML coding – you can <q>comment out</q> code in any XML by wrapping it in comment
               syntax:</p>
                  <pre>&lt;tagged&gt;Text&lt;/tagged&gt;</pre>
                  <p>becomes</p>
                  <pre>&lt;!--  &lt;tagged&gt;Text&lt;/tagged&gt; --&gt;</pre>
                  <p>A code editor that supports XML might let you do this with a keystroke, for example <code>ctrl-,</code>
               (Control key plus comma), after selecting the text you wish to include in the comment.</p>
                  <p>Take care when doing this that the XML is still intact with all the tags balanced. This is a very useful
               technique for rapidly and interactively testing your pipelines.</p>
               </section>
            </section>
            <section>
               <h2>Take note</h2>
               <section>
                  <h3>Where are these downloads coming from?</h3>
                  <p>Pipelines can use a few different strategies for resource acquisition, depending on the case, and on
               where and in what form the resource is available. (Sometimes a file on Github is easiest to download
               "raw", sometimes an archive is downloaded and opened, and so on.) For now, it is not necessary to
               understand details in every case, only to observe the variation and range. (With more ideas welcome.
               Could XProc be used to build a <q>secure downloader</q> that knows how, for example, to compare
               hashes?)</p>
                  <p>Wherever you see <code>href</code> attributes, take note.</p>
                  <p>Since <code>href</code> is how XProc <q>sees</q> the world, either to read data in or to write data out,
               this attribute is a reliable indicator of an assumed feature, often a dependency of some kind. For
               example, a download will not succeed if the resource indicated by the <code>href</code> for the download
               returns an error, or nothing. In XProc, <code>href</code> attribute settings are the <i>points of
                  control</i> for interaction between an XProc pipeline, and its runtime environment.</p>
                  <p>Useful detail: where XProc has <code>p:store href="some-uri.file"</code>, the <code>href</code> is read
               by the processor as the intended location for storage of pipeline data, that is, for a <i>write</i>
               operation. In other cases <code>href</code> is always an argument for a <i>read</i> operation.</p>
               </section>
               <section>
                  <h3>Syntax tips</h3>
                  <p>In XPath syntax, <code>$foo</code> (a name with a <code>$</code> prefixed) indicates a <b>variable
                  reference</b> named (in this case) <q>foo</q>. XProc also uses a <i>value expansion syntax</i>
                  (either<i>text value syntax</i> or <i>attribute value syntax</i>) using curly braces - so syntax such
               as <code>href="{$some-xml-uri}"</code> is not uncommon. Depending on use, this would mean <q>read [or
                  write] to the URI given by <code>$some-xml-uri</code>
                     </q>.</p>
                  <p>An XProc developer always knows where <code>href</code> is used in a pipeline, and how to test for and
               update its use. As always with syntax, the easiest way to learn it is to try making changes and observing
               outcomes.</p>
               </section>
            </section>
         </section>
         <section class="unit"
                  id="unpack_599">
            <h1>599: More context</h1>
            <p>More in depth.</p>
            <section>
               <h2>Goals</h2>
               <ul>
                  <li>Consider XProc in its operational context including available <b>standards</b> and applicable
                  <b>requirements</b>, both generalized and local</li>
                  <li>Learn or relearn some deep XML history including alternative approaches</li>
                  <li>Inform your capability to assess the utility and appropriateness of XProc in particular and XML in
               general, for a given problem or domain</li>
               </ul>
            </section>
            <section>
               <h2>Resources</h2>
               <p>The same pipelines you ran in setup: <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 101</a>.</p>
               <p>Also, <a href="https://xproc.org">XProc.org dashboard page</a>
               </p>
               <p>Also, XProc index materials produced in this repository: <a href="../../../projects/xproc-doc/readme.md">XProc
               docs</a>
               </p>
            </section>
            <section>
               <h2>Prerequisites</h2>
               <p>Same as <a href="../setup/setup_101_src.html"
                     class="LessonUnit">Setup 101</a>. Prior exercises, or the practical equivalent, are
            assumed.</p>
            </section>
            <section>
               <h2>XProc schema</h2>
               <p>A schema for the XProc language, considered as core steps (compound and atomic) plus optional
            community-defined steps, is referenced from the <a href="https://spec.xproc.org/3.0/xproc/#ancillary-files">XProc Specification</a>. <a href="https://spec.xproc.org/3.0/xproc/xproc30.rng">This RNG schema</a> is
            very useful.</p>
               <p>It may often be considered gratuitous to validate XProc files against a schema, when the application (for
            us, Morgana) must in any case take responsibility for conformance issues, as it sees fit. The reference
            schema becomes useful if we find or suspect bugs in Morgana, but until then it need not have any direct role
            in any runtime operation.</p>
               <p>Nevertheless the RNG schema still serves as a reference and an object for querying -- queries whose results
            tell us about XProc. <a href="../../GRAB-XPROC-RESOURCES.xpl">A pipeline</a> for acquiring both RNG schema
            and its RNC (compact syntax) variant is provided for interest and possible later use.</p>
            </section>
            <section>
               <h2>XPath</h2>
               <p>Like other XDM-based technologies, XProc embeds and incorporates XPath, an expression language for XML.
            XPath 3.0 is a functional language in its own right, although not designed for end-to-end processing of
            encoded source data into encoded results, but only for certain critical operations that ordinarily need to
            be performed within such end-to-end processing. Importantly, XPath is defined not in terms of any data
            notation (such as XML syntax or any other) but rather against an <i>abstract data object</i>, namely an <a href="https://www.w3.org/TR/xpath-datamodel/">XDM</a> instance (XML data model), a putative information
            object that may be provided to the system by parsing an XML (syntax) instance, or by other means. As the
            query language for <a href="https://www.w3.org/TR/xpath-datamodel/">XDM</a> and the basis for XQuery, <a href="https://www.w3.org/TR/xpath-31/">XPath</a> is the <q>other half</q> of the data model, which any
            architect of a system using this technology must know. Learning XPath equips you mentally for dealing with
            the XDM in XQuery, XSLT, XProc or anywhere you find it.</p>
               <p>For those not already familiar with XPath, on line resources can be helpful. Keep in mind that <a href="https://www.w3.org/TR/xpath-31/">XPath 3.1</a> outstrips XPath 1.0 in many important respects.</p>
               <section>
                  <h3>Documents and data</h3>
                  <p>One of the more important features of XPath and the XDM is that they are designed not only to meet needs
               for the representation and transmission of structured data. A specialized class of data formats has
               evolved that represent information in ways that are not <q>unstructured</q>, but that contrast with more
               common or usual structures of data formats, whether they be tabular data, serialization formats for
               object models, or some other regular (formalized and codified) arrangement. One might say <q>common</q>
               or <q>usual</q> with reservation, since of course documents are not uncommon where they are common.</p>
                  <p>We see a great deal of structured data these days if only because it is so easy to make structured data
               with machines, and we now have the machines. What remains difficult is to translate what has not been
               created by a machine, into a form that a machine can <q>recognize</q>, or rather into a form we can
               recognize in and with the machine, without destroying it.</p>
                  <p>So documents are called <q>unstructured</q> but they might better be called <q>relatively irregular</q>,
               meaning not that they have no structure, but that each one is structured in itself, and moreover, likely
               to be incompatible or not fully compatible with encodings designed to capture other structures.</p>
                  <p>And to the extent this is the case, any encoding capable of describing documents must have the capability
               of supporting each document's own distinctive structure and organization, whether that be due to its
               family (what is called a <b>document type</b>) or an expression of its own intrinsic logic. The format
               must be not only structured, but <i>structurable</i>, and its structures must to some extent be capable
               of self-description – combining data with metadata.</p>
                  <p>And this is to give no consideration to the fact that these structures can be described at <i>multiple
                  levels</i> of generality or specificity with regard to either their supposed semantics, or their
               configuration in operation.</p>
                  <p>Documentary data formats especially markup formats are designed to work in this in-between space.</p>
                  <p>And so we get XPath - a query syntax which permits working with an organized structure of a particular kind
               (an <i>XDM document tree</i>), which in turn is designed for handling the combination of <i>highly
                  regular</i> and <i>quite irregular</i> data structures that characterize information sets we (loosely)
               call <b>documentary</b>.</p>
                  <p>A definition for what is a document is out of scope for this tutorial – an interesting topic but not only a
               technical one.</p>
               </section>
            </section>
            <section>
               <h2>Survey of XProc elements</h2>
               <p>All elements defined by XProc are listed in this analytical breakout.</p>
               <p>TODO - tbd - reformat this table for legibility (CSS grids); validate its completeness against XProc
            RNG?</p>
               <p>NB - XProc 3.1 makes this a moving target.</p>
               <p>NB also – see Erik Siegel's <a href="https://xprocref.org/index.html">XProcRef</a> indexing project for more
            detailed summaries.</p>
               <table>
                  <tbody>
                     <tr>
                        <th>Function</th>
                        <th>XProc elements / p: namespace</th>
                     </tr>
                     <tr>
                        <td>Documentation</td>
                        <td>
                           <code>p:documentation</code>, , </td>
                     </tr>
                     <tr>
                        <td>Top-level</td>
                        <td>
                           <code>p:declare-step</code>, <code>p:library</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Imports</td>
                        <td>
                           <code>p:import</code>, <code>p:import-functions</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Prologue</td>
                        <td>
                           <code>p:input</code>, <code>p:output</code>, <code>p:option</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Compound steps</td>
                        <td>
                           <code>p:for-each</code>, <code>p:viewport</code>, <code>p:choose</code>, <code>p:when</code>,
                     <code>p:otherwise</code>, <code>p:if</code>, <code>p:group</code>, <code>p:try</code>,
                     <code>p:catch</code>, <code>p:finally</code>, <code>p:run</code>, <code>p:run-input</code>,
                     <code>p:run-option</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - core - XML</td>
                        <td>
                           <code>p:add-attribute</code>, <code>p:add-xml-base</code>, <code>p:delete</code>,
                     <code>p:filter</code>, <code>p:identity</code>, <code>p:insert</code>,
                     <code>p:label-elements</code>, <code>p:make-absolute-uris</code>, <code>p:namespace-delete</code>,
                     <code>p:namespace-rename</code>, <code>p:pack</code>, <code>p:rename</code>,
                  <code>p:replace</code>, <code>p:set-attributes</code>, <code>p:uuid</code>, <code>p:unwrap</code>,
                     <code>p:wrap-sequence</code>, <code>p:wrap</code>, <code>p:xinclude</code>, <code>p:xquery</code>,
                     <code>p:xslt</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - core - zipping</td>
                        <td>
                           <code>p:archive</code>, <code>p:archive-manifest</code>, <code>p:unarchive</code>,
                     <code>p:uncompress</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - core - JSON</td>
                        <td>
                           <code>p:json-join</code>, <code>p:json-merge</code>, <code>p:set-properties</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - core - plain text</td>
                        <td>
                           <code>p:string-replace</code>, <code>p:text-count</code>, <code>p:text-head</code>,
                     <code>p:text-join</code>, <code>p:text-replace</code>, <code>p:text-sort</code>,
                     <code>p:text-tail</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - core - utility</td>
                        <td>
                           <code>p:cast-content-type</code>, <code>p:compare</code>, <code>p:compress</code>,
                     <code>p:count</code>, <code>p:error</code>, <code>p:hash</code>, <code>p:http-request</code>,
                     <code>p:load</code>, <code>p:sink</code>, <code>p:split-sequence</code>, <code>p:store</code>,
                     <code>p:www-form-urldecode</code>, <code>p:www-form-urlencode</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - optional - file system</td>
                        <td>
                           <code>p:directory-list</code>, <code>p:file-copy</code>, <code>p:file-delete</code>,
                     <code>p:file-info</code>, <code>p:file-mkdir</code>, <code>p:file-move</code>,
                     <code>p:file-create-tempfile</code>, <code>p:file-touch</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Atomic steps - optional - validation</td>
                        <td>
                           <code>p:validate-with-nvdl</code>, <code>p:validate-with-relax-ng</code>,
                     <code>p:validate-with-schematron</code>, <code>p:validate-with-xml-schema</code>,
                     <code>p:validate-with-json-schema</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Other optional steps</td>
                        <td>
                           <code>p:os-info</code>, <code>p:os-exec</code>, <code>p:css-formatter</code>,
                     <code>p:xsl-formatter</code>, <code>p:markdown-to-html</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Variable declaration</td>
                        <td>
                           <code>p:variable</code>
                        </td>
                     </tr>
                     <tr>
                        <td>Connectors</td>
                        <td>
                           <code>p:with-input</code>, <code>p:with-option</code>, <code>p:pipe</code>, <code>p:pipeinfo</code>,
                     <code>p:document</code>, <code>p:inline</code>, <code>p:empty</code>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </section>
            <section>
               <h2>XML time line</h2>
               <p>[TODO: complete this, or move it, or both]</p>
               <table>
                  <thead>
                     <tr>
                        <th>Year</th>
                        <th>Publication</th>
                        <th>Capabilities</th>
                        <th>Processing frameworks</th>
                        <th>Platforms</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>1987</td>
                        <td>SGML (ISO-IEC 8879-1)</td>
                        <td>parsing logic; schema validation; configurable syntax; (implicit) tree of elements and
                     attributes</td>
                        <td>Proprietary stacks</td>
                        <td>Mainframes, workstations</td>
                     </tr>
                     <tr>
                        <td>1998</td>
                        <td>XML 1.0</td>
                        <td>standard syntax</td>
                        <td>Batch processing, shell scripts, <code>make</code>
                        </td>
                        <td>Mainframes, workstations, PCs (x86 generation)</td>
                     </tr>
                     <tr>
                        <td>1996</td>
                        <td>Unicode 2.0</td>
                        <td>standard character sets</td>
                        <td>Support for Unicode is slow to come</td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>1999</td>
                        <td>XPath 1.0, XSLT 1.0</td>
                        <td>basic tree querying and transformations (down hill); functional support for namespaces</td>
                        <td>Web browsers? (some, sort of)</td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2000</td>
                        <td>
                        </td>
                        <td>XML-configured software builds</td>
                        <td>Apache Ant</td>
                        <td>Java</td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XQuery 1.0</td>
                        <td>
                        </td>
                        <td>Perl, Python, Java APIs / integration</td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XPath 2.0</td>
                        <td>
                        </td>
                        <td>Server frameworks (Apache Cocoon)</td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2001</td>
                        <td>XML Schema Definition language (XDM)</td>
                        <td>Standardizes atomic data types (foundations of XSD); namespace-based validation (RNG also offers
                     this, 2001-2002)</td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2003-2004</td>
                        <td>W3C Document Object Model (DOM)</td>
                        <td>API for HTML and XML documents</td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2005</td>
                        <td>
                           <q>The XML data model</q> (W3C)</td>
                        <td>An essay</td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2007</td>
                        <td>XSLT 2.0</td>
                        <td>transformations (up hill)</td>
                        <td>XProc 1.0</td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XDM (XPath/XQuery data model)</td>
                        <td>unification</td>
                        <td>
                        </td>
                        <td>Client- and server-side XML processing stacks</td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>XQuery+XSLT in eXist-db or BaseX (XQuery engines)</td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XPath 3.0</td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XPath 3.1</td>
                        <td>higher-order functions, map and array objects</td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XProc 1.0</td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2017</td>
                        <td>XSLT 3.0/3.1</td>
                        <td>JSON harmonization, functions as arguments</td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>
                        </td>
                        <td>XProc 3.0</td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                     <tr>
                        <td>2022</td>
                        <td>Unicode 15.0</td>
                        <td>
                        </td>
                        <td>
                        </td>
                        <td>
                        </td>
                     </tr>
                  </tbody>
               </table>
               <p>The technologies have been in constant use over this period.</p>
               <p>Historically, the requirements of processing frameworks have often been met by software developers' build
            utilities (for example, GNU <code>make</code> or Apache Ant). This is not an accident: in certain respects,
            a publishing framework can be considered as a <q>documentary build</q> at a higher level.</p>
            </section>
            <section>
               <h2>XPath illustrative examples</h2>
               <p>This is not the place to learn XPath, but a selection of XPath expressions can offer a hint of its
            capabilities.</p>
               <table>
                  <thead>
                     <tr>
                        <th>XPath</th>
                        <th>Returns</th>
                        <th>XPath long (explicit) notation</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>
                           <code>/html</code>
                        </td>
                        <td>An XML document root (top-level) element named <code>html</code> (subject to namespace
                     resolution)</td>
                        <td>
                           <code>/child::html</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>//p</code>
                        </td>
                        <td>All the elements named <code>p</code> in the document</td>
                        <td>
                           <code>/descendant-or-self::element()/child::p</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>//seg[@type='null']</code>
                        </td>
                        <td>All the elements named <code>seg</code> with an attribute <code>type</code> with value
                        <code>null</code>
                        </td>
                        <td>
                           <code>/descendant-or-self::element()/child::seg[attribute::type='null']</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>/*</code>
                        </td>
                        <td>Any document (rather, any element at the top of a document) - <code>*</code> is a wildcard
                     character</td>
                        <td>
                           <code>/child::element()</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>/section[exists(.//table)]</code>
                        </td>
                        <td>An element inside the top-level element, named <code>section</code>, that contains a
                        <code>table</code> element anywhere inside it</td>
                        <td>
                           <code>/child::section[exists(self::node()/descendant-or-self::element()/child::table)]</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>/descendant::p[10]</code>
                        </td>
                        <td>The tenth <code>p</code> element in the document</td>
                        <td>
                           <code>/descendant::p[position() eq 10]</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>//p[10]</code>
                        </td>
                        <td>All <code>p</code> elements, that are the tenth <code>p</code> inside their respective
                     parents</td>
                        <td>
                           <code>/descendant-or-self::element()/child::p[position() eq 10]</code>
                        </td>
                     </tr>
                     <tr>
                        <td>
                           <code>//section[count(.//p) gt 10]</code>
                        </td>
                        <td>All <code>section</code> elements that contain more than 10 <code>p</code> elements, at any
                     depth</td>
                        <td>
                           <code>/child::section[count(self::node()/descendant-or-self::element()/child::p) gt
                     10]</code>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </section>
            <section>
               <h2>XML and the XDM: context and rationale</h2>
               <ul>
                  <li>Standard, non-proprietary and freely available without restriction</li>
                  <li>Consistently and repeatedly shown to be capable at scale (size/complexity)</li>
                  <li>Supported by commodity tools, easing problem of proprietary product dependencies</li>
               </ul>
               <p>The technologies we rely on share a common foundation in XML and XDM  (the XML data model), technologies
            developed under the auspices of the World Wide Web Consortium. </p>
               <p>These are supported by commodity tools that are freely available to use without restriction, an important
            qualification for this distribution, which has a prior commitment <i>not to endorse particular technological
               solutions to any problem</i>, however posed or circumscribed. Accordingly, solutions here are not offered
            as recommendations, but rather as stipulations of (minimum) viable functionality in tools or capabilities,
            and not only using tools as <q>black boxes</q>, but under control and conformant to external specifications
            – i.e., standards.</p>
               <p>Users of these tools should keep in mind the model whereby we imagine the viability of a tools market and
            ecosystem that enables both large and small software developers – including independent developers, academic
            researchers, and students – to participate meaningfully, finding an appropriate value or service proposition
            to support immediate and long-term goals. Translated, this means the tools must be capable enough for
            industrial use at scale, while they must also <q>scale down</q> to demonstration or classroom use.</p>
               <p>In web standards including HTML and Javascript (ECMAScript) we arguably have the beginnings of such an
            ecosystem, while it is also contested and turbulent. Within the publishing sector more broadly and
            intersecting with the web, the XML family of standards arguably provides the best demonstration of complete
            or near-complete capabilities at least with respect to the harder problems of document processing.</p>
               <ul>
                  <li>XSLT up to <a href="https://www.w3.org/TR/xslt-30/">XSLT 3.0</a> (in <a href="https://www.saxonica.com/welcome/welcome.xml">Saxon</a>)</li>
                  <li>
                     <a href="https://www.w3.org/TR/xquery-31/">XQuery</a> (in Saxon)</li>
                  <li>
                     <a href="https://github.com/Schematron">Schematron</a> (in <a href="https://github.com/schxslt/schxslt">SchXSLT</a>, an open-source implementation
               in XSLT of <a href="https://schematron.com/">Schematron</a> including the <a href="https://www.iso.org/obp/ui/#iso:std:iso-iec:19757:-3:ed-3:v1:en">ISO/IEC 19757-3</a>
               specification</li>
                  <li>
                     <a href="https://github.com/xspec/xspec">XSpec</a>, a community-maintained XSLT-based framework for
               test-driven development, supporting testing XSLT, XQuery and Schematron</li>
               </ul>
               <p>Since they are known to be highly conformant to their respective specifications as well as well tested,
            these tools provide a useful functional baseline for evaluating other tooling that addresses the same
            functional requirements.</p>
               <p>They are also, relatively speaking, <i>mature</i> technologies, at least in comparison to similar
            offerings.</p>
               <p>And when XProc works, we also have the functional underpinnings we need for comparing - for example -
            different XSLT implementations.</p>
               <p>Initiated in 1996, XML continues to be generative in 2024.</p>
            </section>
            <section>
               <h2>Exercise: Discussion board</h2>
               <p>Create or contribute to a Github discussion board offering perspective or (especially!) relevant information
            or experience on any of the larger questions.</p>
            </section>
         </section>
      </section>
   </body>
</html>