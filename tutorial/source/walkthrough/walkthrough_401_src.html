<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>401 - XSLT, forward and back</title>
   <meta charset="utf-8"/>    </head>
   <body data-track="learner">
      <h1>401 - XSLT Forward and Back</h1>
      <p>What is this XSLT?</p>
      <p>Read this page if you are a beginner, or an expert in XSLT, or if you plan never to use it.</p>
      <section>
         <h2>Goals</h2>
         <ul>
            <li>If you don't know XSLT, helps you understand what it is and what it does</li>
            <li>If you know XSLT, understand something more about how it fits with XProc</li>
         </ul>
      </section>
      <section>
         <h2>Resources</h2>
         <p>XSLT links!</p>
         <section>
            <h3>XSLT 1.0 and XPath 1.0</h3>
         </section>
         <section>
            <h3>XSLT 2.0 and XQuery 1.0</h3>
         </section>
         <section>
            <h3>XSLT 3.0, XQuery 3.0, XPath 3.1</h3>
         </section>
      </section>
      <section>
         <h2>Prerequisites</h2>
         <p>You have run and inspected pipelines mentioned earlier, most especially <a
               href="../../PRODUCE-PROJECTS-ELEMENTLIST.xpl">PRODUCE-PROJECTS-ELEMENTLIST.xpl</a>, which contains
               <code>p:xslt</code> steps.</p>
         <p>You have inspected XSLT files (standalone transformations or <em>stylesheets</em>), to be found more or less
            anywhere in this repository, especially directories named <code>src</code>.</p>
      </section>
      <section>
         <h2>XSLT: XSL (XML Stylesheet Language) Transformations</h2>
         <p>XSLT has a long and checkered reputation and a history that may be even more amazing.</p>
         <p>Chances are good that if you are not current on the latest version of this technology, you have little idea
            of what we are talking about, as it may have changed quite a bit (and even despite external appearances)
            since you last saw it.</p>
         <p>Users who last used XSLT 1.0 and even 2.0, in particular, can consider their knowledge out of date until
            they have taken a look at XSLT 3.0.</p>
         <p>Programmers can think of XSLT as a domain-specific language (DSL) or fourth-generation language (4GL)
            designed for the purpose of manipulating data structures suitable for documents and messages as well as for
            structured data sets. As such, XSLT is highly generalized and abstract and can be applied to a very broad
            range of problems. Its main distinguishing feature among similar languages (which tend to be functional
            languages such as Scala and Scheme) is that it is optimized for use specifically with XML-based data
            formats, offering well-defined handling of information sets expressed in XML, while the language itself uses
            XML syntax, affording nice composability, reflection and code generation capabilities. XSLT's processing
            model is both broadly applicable, and workable in a range of environments including client software or
            within encapsulated, secure software configurations and deployments.</p>
         <p>If your XSLT is strong enough, you don't need XProc, or not much. But as a functional language, XSLT is best
            used in a functionally pure way that does not interact with the system: no <q>side effects</q>. This is
            related to its definitions of conformant processing (X inputs produce Y outputs) and the determinism, based
            in mathematical formalisms, that underlies this idea of conformance. However one cost of mathematical purity
            is that operations that do interact with stateful externalities – things such as reading and writing files –
            are not in XSLT's <q>comfort zone</q>. It easily defines what a new structure A' should look like for any
            given structure A. But how A is first acquired or what we do once we have determined A', is less clear, and
            left up to the processor to handle, as an interface, starting with an XSLT transformation's nominal
               <em>source</em> and (primary) <em>result</em>. Often, this gap has been bridged by extended functionality
            provided by leading processors. Does your processor read and parse XML files off the file system? Can it be
            connected to upstream processes in different ways? Can it use HTTP <code>GET</code> and <code>PUT</code>?
            The answer may be Yes to any or all of these. Throughout its history, XSLT in later versions was also
            extended in this direction, with features such as the <code>collection()</code> function,
               <code>xsl:result-document</code>, <code>doc-available()</code> and other features we don't need if we are
            using XProc.</p>
         <p>Then too, XSLT is commonly run from scripts, in web hosting environments, and indeed from XQuery. Or you
            might be able to configure your desktop software (Editor or IDE) to run your XSLT, or indeed acquire
            specialized software just for reading and filtering collections or managing sets of file outputs in
            XSLT-based workflows.</p>
         <p>It is difficult not to think, however, that a gentler approach is also possible to the range of problems
            related to making XSLT accessible in any environment – one that offers the feature set and flexibility we
            need, but with less overhead, especially with regard to routine chores like designating sets of inputs and
            outputs, or sequencing operations. The principle of Least Power may well apply here: it saves our present
            and our future selves effort if we can arrange and manage to do things less. XProc lets us do less.</p>
         <p>XProc lets us use XSLT when we must, but also keeps routine and simple things both simple and consistent,
            without requiring much overhead. But it adapts itself well to new requirements as they become more
            complicated. Ultimately, it spares the XSLT developer the problem of having to design, build and test
            something like XProc.</p>
         <section>
            <h3>Running XSLT without XProc</h3>
            <p>As a standard and an externally-specified technology, XSLT can in principle be implemented on any
               platform, but the leading XSLT implementation for some years has been Saxon, produced by Saxonica of
               Reading, England. Saxon has achieved market share and developer support on a record of
               strictly-conformant, performant applications, deployed as an open-source software product free for
               developers to use and integrate. (While doing this, Saxonica also has related product offerings including
               optimized processor for those who choose to support it.)</p>
            <p>Download and run Saxon to apply XSLT to XML and other inputs, without XProc.</p>
         </section>
      </section>
      <section>
         <h2>Learning XSLT the safer way</h2>
         <p>If setting out to learn XSLT, pause to read the following list of things to which you should give early
            attention, in order:</p>
         <ol>
            <li>Namespaces in XML and XSLT: names, name prefixes, unprefixed names and the
                  <code>xpath-default-namespace</code> setting (not available until XSLT 2.0)</li>
            <li>Templates and modes in XSLT: template matching, <code>xsl:apply-templates</code>, built-in templates,
               and using modes to configure default behaviors when no template matches</li>
            <li>XPath, especially absolute and relative location paths: start easy and work up</li>
         </ol>
         <p>Only one of these topics does not also apply to XProc.</p>
      </section>
      <section>
         <h2>XProc without XSLT?</h2>
         <p>XProc does not require XSLT absolutely, even if XSLT is indispensable for some of XProc libraries, including
            those in this repository.</p>
         <p>How could we do without it?</p>
         <ul>
            <li>Using XQuery any time queries get complicated</li>
            <li>Use XProc where possible, for example steps that support matches on patterns? E.g.
               <code>p:insert</code>, <code>p:label-elements</code> and <code>p:add-attribute</code></li>
            <li>Reliance on iterators and <code>p:viewport</code></li>
            <li>Much smarter (declarative, data-centric) HTML or other dialect in the application space?</li>
         </ul>
         <p>Chances are, there is a limit. One thing XSLT does better than almost any comparable technology is support
            generalized or granular mappings between vocabularies.</p>
         <p>So not only creating, but also consuming HTML, is the place we begin with XSLT. But since it is also very
            fine for other vocabulary mappings in the middle and back, it becomes indispensable almost as soon as it is
            available for use.</p>
      </section>
      <section>
         <h2>XProc, XDM (the XML data model) and the standards stack</h2>
         <p>Another critical consideration is whether and to what extent XProc and XSLT introduce unwanted dependencies,
            which make them strategically not a good choice (or not a good choice for everyone) at least in comparison
            to alternatives. These are standards in every way including nominally - emerging as the work of
            organizations such as W3C and ISO, while not escaping a reputation as <q>boutique</q> or <q>niche</q>
            technologies. Yet alternative models – whether to go with the big guys, or rely on forests of Javascript
            libraries, or support a bespoke Markdown-based stack – have not all fared very well either. Often scorned,
            XSLT has a reputation for projects migrating away from it as much as towards it. Yet look closely, and when
            problems arise, XSLT is never the issue by itself. Often the question is, were you even using the right
            tool? one way is to be in the sweet spot (and there is a sweet spot) of document processing at scale, but
            this is not definitive. Sometimes the question is, are you actually fitting the capabilities of the
            processing model to the problem at hand. Too often, that fit happens by accident.</p>
         <p>So where has XML-based processing been not only tenable but rewarding over the long term? Interestingly, its
            success is to be found often in projects that have survived across more than one system over time, that have
            grown from one system into another, and that have morphed and adapted and grown new limbs. (Pubmed Central
            comes to mind. But what about Optical Society? PLOS?) In other words, look at them today and you do not see
            the same system as you would have only five years ago.</p>
      </section>
   </body>
</html>