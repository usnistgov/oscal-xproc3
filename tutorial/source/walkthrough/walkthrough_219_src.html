<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>219: XProc, XML and XDM  (the XML Data Model)</title>
   <meta charset="utf-8"/>    </head>
   <body data-track="learner">
      <h1>219: XProc, XML and XDM  (the XML Data Model)</h1>
      <p>More in depth.</p>
      <section>
         <h2>Goals</h2>
         <ul>
            <li>Consider XProc in its operational context including available <b>standards</b> and applicable
                  <b>requirements</b>, both generalized and local</li>
            <li>Consider the context of XProc by learning or relearning some deep XML history</li>
            <li>Inform your capability to assess the utility and appropriateness of XProc in particular and XML in
               general, for a given problem or domain</li>
         </ul>
      </section>
      <section>
         <h2>Resources</h2>
         <p>The same pipelines you ran in setup: <a href="../acquire/acquire_101_src.html" class="LessonUnit">Setup
            101</a>.</p>
         <p>Also, <a href="https://xproc.org">XProc.org dashboard page</a>.</p>
         <p>Also, XProc index materials produced in this repository: <a href="../../../projects/xproc-doc/readme.md"
               >XProc docs</a>.</p>
      </section>
      <section>
         <h2>XProc as XML</h2>
         <p>XProc is defined as an XML vocabulary. A schema for the XProc language, considered as core steps (compound
            and atomic) plus optional community-defined steps, is referenced from the <a
               href="https://spec.xproc.org/3.0/xproc/#ancillary-files">XProc Specification</a>. <a
               href="https://spec.xproc.org/3.0/xproc/xproc30.rng">This RNG schema</a> is very useful.</p>
         <p>It may often be considered gratuitous to validate XProc files against a schema, when the application (for
            us, Morgana) must in any case take responsibility for conformance issues, as it sees fit. The reference
            schema becomes useful if we find or suspect bugs in Morgana, but until then it need not have any direct role
            in any runtime operation.</p>
         <p>Nevertheless, since XProc is XML, its schema still serves as a reference and an object for querying –
            queries whose results tell us about XProc. <a href="../../GRAB-XPROC-RESOURCES.xpl">A pipeline</a> for
            acquiring both the RNG schema and its RNC (compact syntax) variant is provided for interest and possible
            later use.</p>
         <section>
            <h3>Survey of XProc elements</h3>
            <p>All elements defined by XProc (at time of writing) are listed in this analytical breakout.</p>
            <p><i>However</i>, this list is provisional and intended only to offer a wider view. For the most up to date
               information, refer to specifications. In particular, XProc 3.1 makes this list a moving target. This may
               be out of date by the time you are able to read it.</p>
            <p> NB also – see Erik Siegel's <a href="https://xprocref.org/index.html">XProcRef</a> indexing project for
               more detailed summaries.</p>
            <table>
               <tr>
                  <th>Function</th>
                  <th>XProc elements / p: namespace</th>
               </tr>
               <tr>
                  <td>Documentation</td>
                  <td><code>p:documentation</code></td>
               </tr>
               <tr>
                  <td>Top-level</td>
                  <td><code>p:declare-step</code>, <code>p:library</code></td>
               </tr>
               <tr>
                  <td>Imports</td>
                  <td><code>p:import</code>, <code>p:import-functions</code></td>
               </tr>
               <tr>
                  <td>Prologue</td>
                  <td><code>p:input</code>, <code>p:output</code>, <code>p:option</code></td>
               </tr>
               <tr>
                  <td>Compound steps</td>
                  <td><code>p:group</code>, <code>p:for-each</code>, <code>p:viewport</code>, <code>p:if</code>,
                        <code>p:choose</code> (with <code>p:when</code> and <code>p:otherwise</code>),
                        <code>p:try</code> (with <code>p:catch</code> and <code>p:finally)</code>, <code>p:run</code>
                     (with <code>p:run-input</code>, <code>p:run-option</code>)</td>
               </tr>
               <tr>
                  <td>Atomic steps - core - XML</td>
                  <td><code>p:add-attribute</code>, <code>p:add-xml-base</code>, <code>p:delete</code>,
                        <code>p:filter</code>, <code>p:identity</code>, <code>p:insert</code>,
                        <code>p:label-elements</code>, <code>p:make-absolute-uris</code>,
                        <code>p:namespace-delete</code>, <code>p:namespace-rename</code>, <code>p:pack</code>,
                        <code>p:rename</code>, <code>p:replace</code>, <code>p:set-attributes</code>,
                        <code>p:uuid</code>, <code>p:unwrap</code>, <code>p:wrap-sequence</code>, <code>p:wrap</code>,
                        <code>p:xinclude</code>, <code>p:xquery</code>, <code>p:xslt</code></td>
               </tr>
               <tr>
                  <td>Atomic steps - core - zipping</td>
                  <td><code>p:archive</code>, <code>p:archive-manifest</code>, <code>p:unarchive</code>,
                        <code>p:uncompress</code></td>
               </tr>
               <tr>
                  <td>Atomic steps - core - JSON</td>
                  <td><code>p:json-join</code>, <code>p:json-merge</code>, <code>p:set-properties</code></td>
               </tr>
               <tr>
                  <td>Atomic steps - core - plain text</td>
                  <td><code>p:string-replace</code>, <code>p:text-count</code>, <code>p:text-head</code>,
                        <code>p:text-join</code>, <code>p:text-replace</code>, <code>p:text-sort</code>,
                        <code>p:text-tail</code></td>
               </tr>
               <tr>
                  <td>Atomic steps - core - utility</td>
                  <td><code>p:cast-content-type</code>, <code>p:compare</code>, <code>p:compress</code>,
                        <code>p:count</code>, <code>p:error</code>, <code>p:hash</code>, <code>p:http-request</code>,
                        <code>p:load</code>, <code>p:sink</code>, <code>p:split-sequence</code>, <code>p:store</code>,
                        <code>p:www-form-urldecode</code>, <code>p:www-form-urlencode</code></td>
               </tr>
               <tr>
                  <td>Atomic steps - optional - file system</td>
                  <td><code>p:directory-list</code>, <code>p:file-copy</code>, <code>p:file-delete</code>,
                        <code>p:file-info</code>, <code>p:file-mkdir</code>, <code>p:file-move</code>,
                        <code>p:file-create-tempfile</code>, <code>p:file-touch</code></td>
               </tr>
               <tr>
                  <td>Atomic steps - optional - validation</td>
                  <td><code>p:validate-with-nvdl</code>, <code>p:validate-with-relax-ng</code>,
                        <code>p:validate-with-schematron</code>, <code>p:validate-with-xml-schema</code>,
                        <code>p:validate-with-json-schema</code></td>
               </tr>
               <tr>
                  <td>Other optional steps</td>
                  <td><code>p:os-info</code>, <code>p:os-exec</code>, <code>p:css-formatter</code>,
                        <code>p:xsl-formatter</code>, <code>p:markdown-to-html</code></td>
               </tr>
               <tr>
                  <td>Variable declaration</td>
                  <td><code>p:variable</code></td>
               </tr>
               <tr>
                  <td>Connectors</td>
                  <td><code>p:with-input</code>, <code>p:with-option</code>, <code>p:pipe</code>,
                        <code>p:pipeinfo</code>, <code>p:document</code>, <code>p:inline</code>,
                     <code>p:empty</code></td>
               </tr>
            </table>
         </section>
      </section>
      <section>
         <h2>XML and the XDM: context and rationale</h2>
         <p>The technologies we rely on share a common foundation in XML and XDM (the XML data model), technologies
            developed under the auspices of the World Wide Web Consortium (W3C). For stability over a long term (years
            and decades rather than months), we require solutions that are:</p>
         <ul>
            <li>Standard, non-proprietary and freely available without restriction</li>
            <li>Consistently and repeatedly shown to be capable at scale (size/complexity)</li>
            <li>Supported by commodity tools, easing problem of proprietary product dependencies</li>
         </ul>
         <p>Importantly, we need tools that are freely available to use without restriction, an important qualification
            for this distribution, which has a prior commitment <i>not to endorse particular technological solutions to
               any problem</i>, however posed or circumscribed. Accordingly, solutions here are not offered as
            recommendations, but rather as stipulations of (minimum) viable functionality in tools or capabilities, and
            not only using tools as <q>black boxes</q>, but under control and conformant to external specifications –
            i.e., standards.</p>
         <p>Users should keep in mind the model whereby we imagine the viability of a tools market and ecosystem that
            enables both large and small software developers – including independent developers, academic researchers,
            and students – to participate meaningfully, finding an appropriate value or service proposition to support
            immediate and long-term goals. Translated, this means the tools must be capable enough for industrial use at
            scale, while they must also <q>scale down</q> to demonstration or classroom use.</p>
         <p>In web standards including HTML and Javascript (ECMAScript) we arguably have the beginnings of such an
            ecosystem, while it is also contested and turbulent. Within the publishing sector more broadly and
            intersecting with the web, the XML family of standards arguably provides the best demonstration of complete
            or near-complete capabilities at least with respect to the harder problems of document processing.</p>
         <ul>
            <li>XSLT up to <a href="https://www.w3.org/TR/xslt-30/">XSLT 3.0</a> (in <a
                  href="https://www.saxonica.com/welcome/welcome.xml">Saxon</a>)</li>
            <li><a href="https://www.w3.org/TR/xquery-31/">XQuery</a> (in Saxon)</li>
            <li><a href="https://github.com/Schematron">Schematron</a> (in <a href="https://github.com/schxslt/schxslt"
                  >SchXSLT</a>, an open-source implementation in XSLT of <a href="https://schematron.com/"
                  >Schematron</a> including the <a
                  href="https://www.iso.org/obp/ui/#iso:std:iso-iec:19757:-3:ed-3:v1:en">ISO/IEC 19757-3</a>
               specification</li>
            <li><a href="https://github.com/xspec/xspec">XSpec</a>, a community-maintained XSLT-based framework for
               test-driven development, supporting testing XSLT, XQuery and Schematron</li>
         </ul>
         <p>Since they are known to be highly conformant to their respective specifications as well as well tested,
            these tools provide a useful functional baseline for evaluating other tooling that addresses the same
            functional requirements.</p>
         <p>They are also, relatively speaking, <i>mature</i> technologies, at least in comparison to similar
            offerings.</p>
         <p>And when XProc works, we also have the functional underpinnings we need for comparing - for example -
            different XSLT implementations.</p>
         <p>Initiated in 1996, XML continues to be generative in 2024.</p>
      </section>
      <section>
         <h2>Snapshot history: an XML time line</h2>
         <p>[TODO: complete this, or move it, or both] ...</p>
         <table>
            <thead>
               <tr>
                  <th>Year</th>
                  <th>Publication</th>
                  <th>Capabilities</th>
                  <th>Processing frameworks</th>
                  <th>Platforms</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td>1987</td>
                  <td>SGML (ISO-IEC 8879-1)</td>
                  <td>parsing logic; schema validation; configurable syntax; (implicit) tree of elements and
                     attributes</td>
                  <td>Proprietary stacks</td>
                  <td>Mainframes, workstations</td>
               </tr>
               <tr>
                  <td>1996</td>
                  <td>Unicode 2.0</td>
                  <td>standard character sets</td>
                  <td>… support for Unicode is slow to come</td>
                  <td>PCs</td>
               </tr>
               <tr>
                  <td>1998</td>
                  <td>XML 1.0</td>
                  <td>standard syntax</td>
                  <td>Batch processing, shell scripts, <code>make</code></td>
                  <td>Mainframes, workstations, PCs (x86 generation), *nix, shell, sed/awk, Perl</td>
               </tr>
               <tr>
                  <td>1999</td>
                  <td>XPath 1.0, XSLT 1.0</td>
                  <td>basic tree querying and transformations (<q>down hill</q>); functional support for namespaces</td>
                  <td>Web browsers? (some, sort of); standalone XSLT processors</td>
                  <td></td>
               </tr>
               <tr>
                  <td>2000</td>
                  <td></td>
                  <td>XML-configured software builds</td>
                  <td>Apache Ant</td>
                  <td>Java</td>
               </tr>
               <tr>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td>Perl, Python</td>
               </tr>
               <tr>
                  <td></td>
                  <td>XQuery 1.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XPath 2.0</td>
                  <td></td>
                  <td>Server frameworks (Apache Cocoon)</td>
                  <td></td>
               </tr>
               <tr>
                  <td>2001</td>
                  <td>XML Schema Definition language (XDM)</td>
                  <td>Standardizes atomic data types (foundations of XSD); namespace-based validation (RNG also offers
                     this, 2001-2002)</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2003</td>
                  <td></td>
                  <td>Pipelining as a build process</td>
                  <td>Apache Ant</td>
                  <td>Java</td>
               </tr>
               <tr>
                  <td>2003-2004</td>
                  <td>W3C Document Object Model (DOM)</td>
                  <td>API for HTML and XML documents</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2005</td>
                  <td><q>The XML data model</q> (W3C)</td>
                  <td>An essay</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2006</td>
                  <td>XProc 1.0 Requirements</td>
                  <td></td>
                  <td></td>
                  <td>Proof-of-concept demonstrations</td>
               </tr>
               <tr>
                  <td>2007</td>
                  <td>XSLT 2.0</td>
                  <td>Transformations (<q>up hill</q>) including grouping, string processing, pipelining</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XDM (XPath/XQuery data model)</td>
                  <td>Unifying a data model for XPath, XSLT and XQuery</td>
                  <td></td>
                  <td>Client- and server-side XML processing stacks</td>
               </tr>
               <tr>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td>XQuery+XSLT in eXist-db or BaseX (XQuery engines)</td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XPath 3.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XPath 3.1</td>
                  <td>Higher-order functions, map and array objects</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2010</td>
                  <td>XProc 1.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2017</td>
                  <td>XSLT 3.0/3.1</td>
                  <td>JSON harmonization, functions as arguments</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XProc 3.0</td>
                  <td>Easier syntax, plus adding support for JSON and other content types</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2022</td>
                  <td>Unicode 15.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
            </tbody>
         </table>
         <p>The technologies have been in constant use over this period.</p>
         <p>Historically, the requirements of processing frameworks have often been met by software developers' build
            utilities (for example, GNU <code>make</code> or Apache Ant). This is not an accident: in certain respects,
            a publishing framework can be considered as a <q>documentary build</q>, to be run at intervals corresponding to the publishing cycle with its proof runs.</p>
      </section>
      <section>
         <h2>XPath</h2>
         <p>Like other XDM-based technologies, XProc embeds and incorporates XPath, an expression language for XML.
            XPath 3.0 is a functional language in its own right, although not designed for end-to-end processing of
            encoded source data into encoded results, but only for certain critical operations that ordinarily need to
            be performed within such end-to-end processing. Importantly, XPath is defined not in terms of any data
            notation (such as XML syntax or any other) but rather against an <i>abstract data object</i>, namely an <a
               href="https://www.w3.org/TR/xpath-datamodel/">XDM</a> instance (XML data model), a putative information
            object that may be provided to the system by parsing an XML (syntax) instance, or by other means. As the
            query language for <a href="https://www.w3.org/TR/xpath-datamodel/">XDM</a> and the basis for XQuery, <a
               href="https://www.w3.org/TR/xpath-31/">XPath</a> is the <q>other half</q> of the data model, which any
            architect of a system using this technology must know. Learning XPath equips you mentally for dealing with
            the XDM in XQuery, XSLT, XProc or anywhere you find it.</p>
         <p>For those not already familiar with XPath, on line resources can be helpful. Keep in mind that <a
               href="https://www.w3.org/TR/xpath-31/">XPath 3.1</a> outstrips earlier versions of the language in many
            important respects (supporting map and function objects with higher-order functions, among other
            features).</p>
         <section>
            <h3>Documents and data</h3>
            <p>One of the more important features of XPath and the XDM is that they are designed not only to meet needs
               for the representation and transmission of structured data. A specialized class of data formats has
               evolved that represent information in ways that are not <q>unstructured</q>, but that contrast with more
               common or usual structures of data formats, whether they be tabular data, serialization formats for
               object models, or some other regular (formalized and codified) arrangement for purposes of
               machine-readability. One might say <q>common</q> or <q>usual</q> with reservation, since of course
               documents are not uncommon where they are common. The prevalence of so-called structured data in digital
               systems may tell us more about the limits of those systems than it does about information in general.</p>
            <p>We see a great deal of structured data these days if only because it is so easy to make structured data
               with machines, and we now have the machines. What remains difficult is to translate what has not been
               created by a machine, into a form that a machine can <q>recognize</q>, or rather into a form we can
               recognize in and with the machine, without mishandling it and distorting it. Since machines do not
               recognize anything (nothing is <q>mishandling</q> to them), what this often reduces to in practice is
               deciding how to agree on a <b>representation</b> for information that any creator and any consumer can
               recognize and work with, without seeing the information first. In itself this is a formidable
               challenge.</p>
            <p>So documents are called <q>unstructured</q> but they might better be called <q>relatively irregular</q>,
               meaning not that they have no structure, but that each one is structured in itself, and moreover, likely
               to be incompatible or not fully compatible with encodings designed to capture other structures.</p>
            <p>And to the extent this is the case, any encoding capable of describing documents must have the capability
               of supporting each document's own distinctive structure and organization, whether that be due to its
               family (what is called a <b>document type</b>) or an expression of its own intrinsic logic. The format
               must be not only structured, but <i>structurable</i>, and its structures must to some extent be capable
               of self-description – combining data with metadata.</p>
            <p>And this is to give no consideration to the fact that these structures can be described at <i>multiple
                  levels</i> of generality or specificity with regard to either their supposed semantics, or their
               configuration in operation.</p>
            <p>Documentary data formats especially markup formats are designed to work in this in-between space.</p>
            <p>And so we get XPath - a query syntax which permits working with an organized structure of a particular
               kind (an <i>XDM document tree</i>), which in turn is designed for handling the combination of <i>highly
                  regular</i> and <i>quite irregular</i> data structures that characterize information sets we (loosely)
               call <b>documentary</b>.</p>
            <p>A definition for what is a document is out of scope for this tutorial – an interesting topic but not only
               a technical one.</p>
         </section>
         <section>
            <h3>XPath illustrative examples</h3>
            <p>This is not the place to learn XPath, but a selection of XPath expressions can offer a hint of its
               capabilities.</p>
            <table>
               <thead>
                  <tr>
                     <th>XPath</th>
                     <th>Returns</th>
                     <th>XPath long (explicit) notation</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td><code>/html</code></td>
                     <td>An XML document root (top-level) element named <code>html</code> (subject to namespace
                        resolution)</td>
                     <td><code>/child::html</code></td>
                  </tr>
                  <tr>
                     <td><code>//p</code></td>
                     <td>All the elements named <code>p</code> in the document</td>
                     <td><code>/descendant-or-self::element()/ child::p</code></td>
                  </tr>
                  <tr>
                     <td><code>//seg[@type='null']</code></td>
                     <td>All the elements named <code>seg</code> with an attribute <code>type</code> with value
                           <code>null</code></td>
                     <td><code>/descendant-or-self::element()/ child::seg[attribute::type='null']</code></td>
                  </tr>
                  <tr>
                     <td><code>/*</code></td>
                     <td>Any document (rather, any element at the top of a document) - <code>*</code> is a wildcard
                        character</td>
                     <td><code>/child::element()</code></td>
                  </tr>
                  <tr>
                     <td><code>/section[exists(.//table)]</code></td>
                     <td>An element inside the top-level element, named <code>section</code>, that contains a
                           <code>table</code> element anywhere inside it</td>
                     <td><code>/child::section[exists(self::node()/ descendant-or-self::element()/ child::table)]</code></td>
                  </tr>
                  <tr>
                     <td><code>/descendant::p[10]</code></td>
                     <td>The tenth <code>p</code> element in the document</td>
                     <td><code>/descendant::p[position() eq 10]</code></td>
                  </tr>
                  <tr>
                     <td><code>//p[10]</code></td>
                     <td>All <code>p</code> elements, that are the tenth <code>p</code> inside their respective
                        parents</td>
                     <td><code>/descendant-or-self::element()/ child::p[position() eq 10]</code></td>
                  </tr>
                  <tr>
                     <td><code>//section[count(.//p) gt 10]</code></td>
                     <td>All <code>section</code> elements that contain more than 10 <code>p</code> elements, at any
                        depth</td>
                     <td><code>/child::section[count(self::node()/ descendant-or-self::element()/ child::p) gt
                        10]</code></td>
                  </tr>
               </tbody>
            </table>
            <p>Where do you find XPath? Any <code>select</code> or <code>match</code> expression in XSLT or XProc shows
               an example. XPath also constitutes the core of XQuery.</p>
         </section>
      </section>
      <section>
         <h2>Exercise: Discussion board</h2>
         <p>Create or contribute to a Github discussion board offering perspective or (especially!) relevant information
            or experience on any of the larger questions.</p>
      </section>
   </body>
</html>