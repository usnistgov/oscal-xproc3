<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>101: OSCAL from XML to JSON and back</title>
      <meta charset="utf-8" />
   </head>
   <body data-track="observer">
      <h1>101: OSCAL from XML to JSON and back</h1>
      <section>
         <h2>Goals</h2>
         <p>Learn how OSCAL data can be converted between JSON and XML formats, using XProc.</p>
         <p>Learn something about potential problems and limitations when doing this, and about how to detect, avoid,
            prevent or mitigate them.</p>
      </section>
      <section>
         <h2>Prerequisites</h2>
         <p>You have succeeded in prior exercises, including tools installation and setup.</p>
      </section>
      <section>
         <h2>Resources</h2>
         <p>This unit relies on the <a href="../../../projects/oscal-convert/readme.md">oscal-convert project</a> in
            this repository, with its files. Like all projects in the repo, it aims to be reasonably self-contained and
            self-explanatory. Use your search engine and XProc resources to learn background and terminology.</p>
         <p>Also like other projects, there are preliminaries for acquiring resources, along with pipelines to run.</p>
      </section>
      <section>
         <h2>Step zero: an identity pipeline</h2>
         <p>To verify syntactic correctness (well-formedness) - does it parse?</p>
         <p>To transcode a file from one encoding to another</p>
         <section>
            <h3>0.01 - what is a <q>document</q></h3>
            <h3>0.1 - loading documents known in advance</h3>
            <h3>0.2 - binding a document to an input port</h3>
            <h3>0.3 - loading documents dynamically on discovery with <code>p:directory-list</code></h3>
            <h3>0.4 - saving results to the file system</h3>
            <h3>0.5 - exposing results on an output port</h3>
         </section>
      </section>
      <section>
         <h2>Step zero-point-five: XML to JSON and back</h2>
         <p>XML and JSON are both <i>data serializations</i>, a term that designates how each of them is to be
            considered and treated – irrespective of any questions of information storage – as a <i>sequence of
               characters</i>. This is a very important commonality, which makes it possible to bring them together in a
            single processing environment such as XProc.</p>
         <p>Along with <i>plain text</i>, perhaps the most important data serialization or <q>format</q> as we call
            them, of the three.</p>
         <p>A simple XProc pipeline can be used to demonstrate this. While doing so, it shows also while this is not as
            simple a process as it seems. Merely to convert from format to format is not enough.</p>
      </section>
      <section>
         <h2>Step one: convert some OSCAL XML into OSCAL JSON</h2>
         <p><a href="../../../projects/oscal-convert/GRAB-RESOURCES.xpl">An acquisition pipeline</a> in the project
            folder collects some OSCAL onto the local system, where it can be managed, easily inspected, controlled, and
            edited if necessary.</p>
         <p>TBD / this all incoherent so far</p>
         <section>
            <h3>The playing field is the internet</h3>
            <p>Keep in mind that XProc in theory, and your XProc engine in practice, may read its inputs using whatever
               protocols it supports, while the <code>file</code> and <code>http</code> protocols are required for
               conformance, and work as they do on the Worldwide Web.</p>
            <p>Of course, permissions must be in place to read files from system locations, or save files to them.</p>
            <p>But when authentication is configured or resources are openly available, using <code>http</code> to reach
               resources or sources can be a very convenient option.</p>
         </section>
         <section>
            <h3>Consider the options</h3>
            <p>TBD - TODO - question - how many and of what sort of source data files - so far there is only the cat
               catalog</p>
            <ul>
               <li>Converting local XML to JSON with a local XSLT</li>
               <li>Converting local data using a remote XSLT</li>
               <li>Remote data with a local XSLT, writing locally - you could try <a
                     href="https://github.com/GSA/fedramp-automation/blob/master/dist/content/rev5/baselines/xml/FedRAMP_rev5_LOW-baseline-resolved-profile_catalog.xml"
                     >https://github.com/GSA/fedramp-automation/blob/master/dist/content/rev5/baselines/xml/FedRAMP_rev5_LOW-baseline-resolved-profile_catalog.xml</a></li>
            </ul>
         </section>
      </section>
      <section>
         <h2>Step two: return trip</h2>
         <p>Two ways: separate pipeline; and single pipeline; also a 'switcher' pipeline?</p>
      </section>
      <section>
         <h2>Designating an input at runtime</h2>
         <p>One potential problem with the pipelines we have looked at so far is that their inputs are hard-wired. While
            this is sometimes helpful, it should also be possible to apply a pipeline to an XML document (or other
            input) without having to designate the document inside the pipeline itself. The user or calling application
            should be able to say <q>run this pipeline, but this time with this input</q>.</p>
         <p>The input ports for a pipeline, specified using <code>p:input</code> within the prologue, provide for
            this.</p>
         <p>For example, the <a href="../../../projects/oscal-convert/CONVERT-OSCAL-XML-DATA.xpl"
               >CONVERT-OSCAL-XML-DATA</a> pipeline defines an input port:</p>
         <pre>&lt;p:input port="source" sequence="true">
    &lt;p:document href="data/catalog-model/xml/cat_catalog.xml"/>
&lt;/p:input></pre>
         <p>By default, this pipeline will pick up and process the data it finds at path
               <code>data/catalog-model/xml/cat_catalog.xml</code>, relative to the stylesheet. But any call to this
            pipeline, whether directly or as a step in another pipeline, can override this.</p>
         <p>The Morgana processor defines <a href="https://www.xml-project.com/manual/ch01.html#R_ch1_s1_2">a command
               syntax for binding inputs to ports</a>. It looks like this (when used with the script deployed with this
            repository):</p>
         <pre>$ ../xp3.sh <i>PIPELINE.xpl</i> -input:<i>portname=path/to/a-document.xml</i> -input:<i>portname=path/to/another-document.xml</i></pre>
         <p>Here, two different <code>-input</code> arguments are given for the same port. You can have as many as
            needed if the port, like this one, has <code>sequence="true"</code>, meaning any number of documents (from
            zero to many) can be bound to the port, and the pipeline will accommodate. When more than one port is
            defined, one (only) can be designated as <code>primary="true"</code>, meaning it will be provided implicitly
            when a port connection is required (by a step) but not given in the pipeline. Notice that the name of the
            port must also appear, as in <code>-input:portname</code>, since pipelines can have ports supporting
            sequences, but also as many input ports as it needs, named differently, for documents playing different
            roles in the pipeline. In place of <code>portname</code> here, a common name for a port (conventional when
            it is the pipeline's only or primary input) is <code>source</code>.</p>
         <p>The <a href="oscal-convert_102_src.html" class="LessonUnit">102 Lesson unit</a> in this Lesson offers a
            chance to use this feature [<b>XXX confirm this</b>].</p>
         <section>
            <h3>XXX move me</h3>
            <p>If you wish to hard-code an input document, <code>p:load</code> will work. But only a single document can
               be loaded this way. the inputs are always hard-coded and this should not be possible, you can use
                  <code>p:load</code> inside the pipeline, and not define a port. Without a port, the XProc offers no
               way to bind inputs dynamically.</p>
            <p>If you wish to acquire more than a single document that the caller cannot override, make a step like
               this:</p>
            <pre>&lt;p:identity>
  &lt;p:with-input port="source">
    &lt;p:document href="..."/>
    &lt;p:document href="..."/>
    ...
  &lt;/p:with-input>
&lt;p:identity></pre>
            <p>This binds the documents to the input of an <b>identity</b> step (which supports a sequence), without
               exposing an input port in the main pipeline.</p>
            <p>Note that one potential disadvantage of this is that errors for missing documents are reported when the
               XProc is compiled, not when it is run.</p>
         </section>
      </section>
      <section>
         <h2>Overview: the anatomy of an XProc pipeline</h2>
         <p>Experts in XML can read this section quickly. Newcomers will find some of the concepts here (such as
            namespaces) also apply across XML- and XDM-based technologies including XSLT and Schematron. XDM is the <a
               href="https://www.w3.org/TR/xpath-datamodel/">XQuery and XPath Data Model</a>, the foundation of XPath,
            XQuery and XSLT.</p>
         <section>
            <h3>XProc files</h3>
            <p>An XProc pipeline takes the form of an XML <q>document entity</q>. Unless you are concerned to write an
               XML parser (which is not very likely for XProc's natural constituency), this typically means an XML file,
               that is to say a file encoded in plain text (typically the UTF-8 serialization of Unicode, or
               alternatively another form of <q>plain text</q> supported by your toolkit), and following the rules of
               XML syntax. These rules include how elements and attributes and other XML features are encoded in
                  <b>tags</b> that</p>
            <ul>
               <li>Follow the rules with respect to naming, whitespace, delimiters and reserved characters</li>
               <li>Are correctly balanced, with an end tag for every start tag – for a <code>&lt;start></code> there
                  must be a <code>&lt;/start></code> (an end to the start).</li>
               <li>Are cleanly nested with no overlap: end tags always close the most recently opened element, so no
                  element ever extends beyond the boundaries of its <q>ancestor</q> or containing elements</li>
            </ul>
            <p>These rules are fairly simple, and they are well supported by tools designed to read and write XML – to
               respect, follow and enforce the rules on our behalf.</p>
            <p>Thus they are also quickly and easily internalized, often in only a few minutes of working with XML.</p>
            <p>Over and above being XML, XProc has some rules of its own ...</p>
            <section>
               <h4>XProc document element</h4>
               <pre>&lt;p:declare-step version="3.0"
   xmlns:p="http://www.w3.org/ns/xproc"
   xmlns:ox="http://csrc.nist.gov/ns/oscal-xproc3"
   type="ox:TEST-XPROC3"
   name="TEST-XPROC3">
...
&lt;/p:declare-step></pre>
            </section>
            <section>
               <h4>Namespaces</h4>
               <pre>   xmlns:p="http://www.w3.org/ns/xproc"
   xmlns:ox="http://csrc.nist.gov/ns/oscal-xproc3"</pre>
            </section>
            <section>
               <h4>@name and @type</h4>
               <p>On <code>p:declare-step</code>, whether at the top or in a step definition within a pipeline, either
                  or both a <code>@name</code> and a <code>@type</code> are permitted.</p>
               <pre>   type="ox:TEST-XPROC3"
   name="TEST-XPROC3"></pre>
               <p>The name makes it possible to reference the step by name. This is often useful and sometimes more or
                  less essential, for example for providing input to one step from another step's output. (We say
                     <q>more or less essential</q> because the processor will produce names for itself as a fallback, if
                  it needs them, but these are brittle, somewhat opaque – such as <code>!1.2.3</code> – and more
                  difficult to use than the names a developer gives.)</p>
               <p>Understandably, the name of an XProc must be different from the names given to all the steps in the
                  XProc (which must also be distinct). </p>
               <p>This repository follows a rule that a step name should correspond to its file base name (i.e., without
                  a filename suffix), so <code>identity_</code> for <code>identity_.xproc</code>, etc. But that is a
                  rule for us, not for XProc in general.</p>
               <p>A step may also have an assigned <code>@type</code>. Unlike the name, which can be in any namespace or
                  none, the <code>@type</code> must be assigned to a namespace.</p>
            </section>
         </section>
         <section>
            <h3>Prologue and body</h3>
            <p>Keep in mind that to build a pipeline is also to design and deploy a step, since any pipeline can be used
               as a step, and any step may comprise, internally, a pipeline.</p>
            <p>Since step definitions are more often <q>out of line</q> (in an external file) than inline (in the XProc
               itself), </p>
            <p>As described in the <a href="https://spec.xproc.org/3.0/xproc/#declare-pipelines">XProc 3.0
                  specification</a>, XProc step declarations can be divided into an initial set of elements for setup
               and configuration, followed by what the specification calls a <i>subpipeline</i>, consisting of a
               sequence of steps to be executed – any steps available, which could be anything. Think of the subpipeline
               as the working parts of the pipeline, while the rest is all about how it is set up.</p>
            <p>The list of elements that come before the subpipeline is short, which helps: <code>p:import</code>,
                  <code>p:import-functions</code>, <code>p:input</code>, <code>p:output</code>, <code>p:option</code> or
                  <code>p:declare-step</code>. Everything coming after is a step.</p>
            <p>Within this set of elements (all preceding, none following the subpipeline) XProc further distinguishes
               between the <b>imports</b> for steps and functions, appearing first (elements <code>p:import</code> and
                  <code>p:import-functions</code>), to be followed by elements configuring the step:
                  <code>p:input</code>, <code>p:output</code>, <code>p:option</code> – elements together called the <a
                  href="https://spec.xproc.org/3.0/xproc/#declare-pipelines">prologue</a>.</p>
            <p>The prologue is used to define ports and options for the pipeline. It can be thought of as the definition
               of the interface for the step as a whole. Defining ports and options is how you give the users of the
               step with the affordances or control points they need to use it. If only a single input is needed, a
               single input port (named <code>source</code>) can be assumed (XXX is this so?), so prologues can be empty
               (and invisible, or not there).</p>
            <p>Following the prologue, a step may also have local step definitions (<code>p:declare-step</code>). One
               might think of these as macros: maybe they are never used by another pipeline (XXX test: is this even
               possible?), but these locally-defined pipelines can be used internally for logic that is used repeatedly,
               or that warrants separating from the main pipeline for some other reason.</p>
            <p>After imports, prologue and (optional) step declarations, the step sequence that follows comprises the <a
                  href="https://spec.xproc.org/3.0/xproc/#dt-subpipeline">subpipeline</a>.</p>
            <p>One other complication: among the steps in the subpipeline, <code>p:variable</code> (a variable
               declaration) and <code>p:documentation</code> (for out-of-band documentation) are also permitted – these
               are not properly steps, but can be useful to have with them.</p>
            <p>In summary: any XProc pipeline, viewed as a step declaration, can have the following --</p>
            <ul>
               <li>Pipeline name and type assignment (if needed), given as attributes at the top</li>
               <li><b>Imports</b>: step declarations, step libraries and functions to make available</li>
               <li>The pipeline <b>prologue</b>: any of the elements named <code>p:input</code>, <code>p:output</code>
                  and <code>p:option</code>, defining this pipeline's ports and options<ul>
                     <li>If no ports are named, assume a single <code>source</code> primary input port, permitting a
                        single document</li>
                  </ul></li>
               <li>Optionally (and not common): step declarations for local steps, appearing at
                     <code>p:declare-step</code>. Each of these will have its own name, type, prologue and steps</li>
               <li>For this pipeline, one or more steps, called the <a
                     href="https://spec.xproc.org/3.0/xproc/#dt-subpipeline">subpipeline</a><ul>
                     <li>Standard atomic and compound steps in XProc namespace (probably prefixed <code>p:</code>)</li>
                     <li>Imported steps - in their own namespaces (in this repository, prefixed <code>ox:</code>)</li>
                     <li>Variable declarations - <code>p:variable</code></li>
                  </ul></li>
               <li>Finally, as noted above, <code>p:documentation</code> can appear anywhere in a pipeline, but it will
                  be ignored except when appearing inside <code>p:inline</code>. What to do with these is a topic to be
                  covered later.</li>
            </ul>
            <p>NB: the pipelines run so far have XML comments demarcating the prologue from the steps.</p>
         </section>
         <section>
            <h3>XProc steps</h3>
            <p>The <i>step</i> is the core conceptual unit of XProc. An XProc processing pipeline is composed of steps.
               But a pipeline is also considered as a step in itself. As such it can be used in other pipelines, and so
               on.</p>
            <p>In other words, steps in XProc are <i>compositional</i>. They are building block assemblies made out of
               smaller building block assemblies. A step is a way to process data. A pipeline is a way of orchestrating
               and arranging such processes.</p>
            <p>The distinction between pipelines and steps is relative and provisional, but important and useful. The
               pipeline is the logical and actual definition of how your data is to be processed. Every pipeline is
               composed of an arrangement, often a series, of operations. These operations – the steps – include
                  <q>primitives</q>, being designed for generality and reusability for the most common operations. But
               they can also include new steps we have written, as pipelines, and such custom-designed steps can be used
               in combination with the primitives or core compound steps of the language.</p>
            <p>At a higher level, defining new steps with new step declarations, and using them in combination with
               other steps, is how we manage complexity and change in processing requirements. This strategy maximizes
               adaptability, while also supporting an <q>incremental maturity model</q>, in which all defined processes
               can be improved with reuse, building and testing over time. Careful use and deployment of new steps is
               how we save work, by focusing optimization and making it possible to scale up to address data processing
               requirement sets that are both large and complex.</p>
            <p>Accommodating this design, an XProc <i>file</i> considered as an XML instance is either of two things: a
                  <i>step declaration</i>, or a collection of such declarations, a <i>library</i>. At the top level,
               recognize an XProc step declaration by the element, <code>p:declare-step</code> (in the XProc namespace)
               and a library by the element <code>p:library</code>.</p>
            <pre>&lt;p:declare-step xmlns:p="http://www.w3.org/ns/xproc" version="3.0" 
    name="a-first-step">
...
&lt;/p:declare-step></pre>
            <p>Additionally, step declarations can include their own pipeline (step) declarations, making a hybrid
               architecture: the pipeline comprises a step, with its own library not imported but in line. This can also
               be useful.</p>
            <p>An example of a step library in this repository is <a href="../../../xspec/xspec-execute.xpl"
                  >xspec-execute.xpl</a>, which collects several steps supporting XSpec, one each for supporting the
               XSpec testing framework for XSLT, XQuery and Schematron respectively.</p>
            <p>The advantage of defining a step at the top level, rather than putting all steps into libraries, is that
               such a step can be invoked without prior knowledge of its type name, which is used by XProc to
               distinguish it from other steps. The pipeline simply needs to be presented to the processor, which does
               the rest.</p>
            <section>
               <h4>XProc as an XML document</h4>
               <p>Like any language using XML syntax, XProc depends on a conceptual relation between primitive
                  constructs of the language, and XML syntax, a relation that is ordinarily (and usefully) mediated by
                  means of an (actual or putative) XML <i>data model</i> including elements, attributes, comment nodes,
                  text nodes and so forth. XSLT is such a language, for example: it has its top-level
                     <i>declarations</i>, its <i>template rules</i> and its <i>instructions</i>, all of which are
                  represented using elements in the (standard and most commonly used) XML syntax. Thus, part of learning
                  XSLT is learning that <code>xsl:key</code> is syntax for a <q>key declaration</q> while
                     <code>xsl:template</code> is a <q>template rule</q>.</p>
               <p>In the same way, elements in XProc's XML vocabulary correspond to structures in XProc - structures
                  which developers and users rely on, as they define both the internals and the <q>control interface</q>
                  for the language as a semantic construct - something that <q>does something</q>. In XProc, those
                  structures include things like <b>documents</b>, <b>content-types</b> (think of <q>formats</q> such as
                  XML and JSON), <b>ports</b> and <b>steps</b>. Some XProc elements represent steps, others do not. (In
                  the same way as an XSLT key declaration is not a template rule.) Learning this difference among others
                  is how you learn XProc.</p>
               <p>Fortunately, the vocabulary of the language is not very large. Core XProc 3.0 has only 95 elements
                  defined in its namespace (or 99, if you are strictly counting all element types defined, not just the
                  names those elements are given). XProc 3.1 adds a few more. This includes elements for all the core
                  and community-defined steps (recognizable by the prefix <code>p:</code>). Additional to these 95 might
                  be other steps you acquire or define. As with any language, there are parts you will hardly ever use,
                  while other parts are used routinely.</p>
            </section>
            <section>
               <h4>XProc embedded documentation</h4>
               <p>An example of this is the XProc <code>p:documentation</code> element. This element is designed to
                  carry documentation to a consuming application. Rather than mandate some kind of behavior for
                     <code>p:documentation</code> – something difficult or impossible to do for the general case, or to
                  test –- the XProc rule is <q>anything marked as documentation is for some other consumer</q>, i.e. a
                  documentation engine, not the XProc processor. In other words, a conformant processor <a
                     href="https://spec.xproc.org/3.0/xproc/#documentation"><i>must ignore</i> anything it sees</a>
                  inside <code>p:documentation</code>.</p>
               <p>There is a small loophole, namely that the effect of <code>p:inline</code> for capturing XML overrides
                  this provision, so if you put <code>p:documentation</code> inside <code>p:inline</code>, it <q>becomes
                     visible</q> as inline content, not as XProc to be operated on (or not).</p>
               <p>As always it is up to the developer how thoroughly and in what form to include inline documentation.
                  And short of managing a corpus of code documentation along with the code, placing explanatory remarks
                  and code snippets into comments is a widely followed practice, and recommended for its combination of
                  ease and usefulness.</p>
            </section>
         </section>
         <section>
            <h3>Atomic and compound steps</h3>
            <p>Given an understanding of the organization of an XProc pipeline, the focus shifts to the steps
               themselves, which follow a common pattern. Briefly put, an atomic step is any step you use by simply
               invoking it with inputs and options: its logic is self-contained, and the operation it carries out is (at
               least conceptually) <q>single</q> and unified. A compound step, in contrast, combines one or more other
               steps in a <em>subpipeline</em> and manages these together.</p>
            <p>XProc keeps things workable by providing only a few compound steps supporting the identified range of
               needs. This does not prove to be a practical limitation, since atomic steps can have multiple inputs and
               outputs, distinguished by type and role. (For example, a validation step might output both a copy of the
               input, potentially annotated, along with a validation report.) Atomic steps are not necessarily simple,
               and may include compound steps in their own subpipelines, either externally or even within the same step
               declaration.</p>
            <p>Here are all the compound steps. All others are atomic steps.</p>
            <ul>
               <li><a href="https://spec.xproc.org/3.0/xproc/#p.group"
                     style="color: rgb(3, 69, 117); text-decoration: none; border-bottom: 1px solid rgb(112, 112, 112); padding: 0px 1px; margin: 0px -1px; font-family: sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -120px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;"
                        ><code class="tag-element language-construct"
                        style="font-family: Consolas, Monaco, &#34;Andale Mono&#34;, monospace; font-size: 16px; break-inside: avoid; hyphens: none; text-transform: none; text-align: left; white-space: pre; color: black; text-shadow: white 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; padding: 0.1em; border-radius: 0.3em;"
                        >p:group</code></a> - group a subpipeline (step sequence) into a single logical step</li>
               <li><a href="https://spec.xproc.org/3.0/xproc/#p.if"
                     style="color: rgb(3, 69, 117); text-decoration: none; border-bottom: 1px solid rgb(112, 112, 112); padding: 0px 1px; margin: 0px -1px; font-family: sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -120px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;"
                        ><code class="tag-element language-construct"
                        style="font-family: Consolas, Monaco, &#34;Andale Mono&#34;, monospace; font-size: 16px; break-inside: avoid; hyphens: none; text-transform: none; text-align: left; white-space: pre; color: black; text-shadow: white 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; padding: 0.1em; border-radius: 0.3em;"
                        >p:if</code></a> - execute a subpipeline conditionally</li>
               <li><a href="https://spec.xproc.org/3.0/xproc/#p.choose"
                     style="color: rgb(3, 69, 117); text-decoration: none; border-bottom: 1px solid rgb(112, 112, 112); padding: 0px 1px; margin: 0px -1px; font-family: sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -120px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;"
                        ><code class="tag-element language-construct"
                        style="font-family: Consolas, Monaco, &#34;Andale Mono&#34;, monospace; font-size: 16px; break-inside: avoid; hyphens: none; text-transform: none; text-align: left; white-space: pre; color: black; text-shadow: white 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; padding: 0.1em; border-radius: 0.3em;"
                        >p:choose</code></a> - execute a subpipeline conditionally (<code>switch/case</code>
                  operator)</li>
               <li><a href="https://spec.xproc.org/3.0/xproc/#p.for-each"
                     style="color: rgb(3, 69, 117); text-decoration: none; border-bottom: 1px solid rgb(112, 112, 112); padding: 0px 1px; margin: 0px -1px; font-family: sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -120px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;"
                        ><code class="tag-element language-construct"
                        style="font-family: Consolas, Monaco, &#34;Andale Mono&#34;, monospace; font-size: 16px; break-inside: avoid; hyphens: none; text-transform: none; text-align: left; white-space: pre; color: black; text-shadow: white 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; padding: 0.1em; border-radius: 0.3em;"
                        >p:for-each</code></a> - produce subpipeline results for each member of a sequence of inputs
                  (documents or nodes)</li>
               <li><a href="https://spec.xproc.org/3.0/xproc/#p.viewport"
                     style="color: rgb(3, 69, 117); text-decoration: none; border-bottom: 1px solid rgb(112, 112, 112); padding: 0px 1px; margin: 0px -1px; font-family: sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -120px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;"
                        ><code class="tag-element language-construct"
                        style="font-family: Consolas, Monaco, &#34;Andale Mono&#34;, monospace; font-size: 16px; break-inside: avoid; hyphens: none; text-transform: none; text-align: left; white-space: pre; color: black; text-shadow: white 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; padding: 0.1em; border-radius: 0.3em;"
                        >p:viewport</code></a> - reproduce outputs, except splicing subpipeline results in place of
                  matched nodes (elements) in the input</li>
               <li><a href="https://spec.xproc.org/3.0/xproc/#p.try"
                     style="color: rgb(3, 69, 117); text-decoration: none; border-bottom: 1px solid rgb(112, 112, 112); padding: 0px 1px; margin: 0px -1px; font-family: sans-serif; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: -120px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal;"
                        ><code class="tag-element language-construct"
                        style="font-family: Consolas, Monaco, &#34;Andale Mono&#34;, monospace; font-size: 16px; break-inside: avoid; hyphens: none; text-transform: none; text-align: left; white-space: pre; color: black; text-shadow: white 0px 1px; direction: ltr; word-spacing: normal; word-break: normal; tab-size: 4; padding: 0.1em; border-radius: 0.3em;"
                        >p:try</code></a> - execute a subpipeline, and deliver its results, or if it fails, a fallback
                  subpipeline given in a <code>p:catch</code></li>
            </ul>
            <p>Additionally to these elements, XProc subpipelines may contain variable declarations and documentation,
               as noted.</p>
         </section>
         <section>
            <h3>Namespaces and extension steps</h3>
            <p>We recognize steps because we either recognize them by name - for standard steps in the <code>p:</code>
               (XProc) namespace such as <code>p:filter</code> and <code>p:add-attribute</code> - or because we do not.
               Extension steps in XProc take the form of elements in an extension namespace. Generally speaking, that
               is, any element not prefixed with <code>p:</code> is treated as out of scope for XProc and to be ignored,
               while subject to evaluation as an extension.</p>
            <p>In an XProc pipeline (library or step declaration) one may also see a namespace <code>c:</code>. TODO -
               come back to</p>
            <details>
               <summary>Question: Where are extension steps used in the XProcs run so far?</summary>
               <p>Answer: The <a href="./../../../smoketest/TEST-XSPEC.xpl">XSpec smoke test</a> calls an extension step
                  named <code>ox:execute-xspec</code>, defined in an imported pipeline. In this document, the prefix
                     <code>ox</code> is bound to a utility namespace,
                  <code>http://csrc.nist.gov/ns/oscal-xproc3</code>.</p>
            </details>
         </section>
         <section>
            <h3>Schema for XProc 3.0</h3>
            <p>See the <a href="../unpack/unpack_599_src.html" class="LessonUnit">599-level coverage in this lesson
                  unit</a> for a discussion of the schema for XProc.</p>
         </section>
      </section>
      <section>
         <h2>Some breaking and making</h2>
         <p>Every project you examine provides an opportunity to alter pipelines and see how they fail when not encoded
            correctly – when <q>broken</q>, any way we can think of breaking them. Then build good habits by repairing
            the damage. Experiment and observation bring learning.</p>
         <p>After reading this page, perform some more disassembly / reassembly. Here are a few ideas:</p>
         <ul>
            <li>Switch out the value of an <code>@href</code> on a <code>p:document</code> or <code>p:load</code> step.
               See what happens when the file it points to is not actually there.</li>
            <li>There is a difference between <code>p:input</code>, used to configure a pipeline in its prologue, and
                  <code>p:load</code>, a step that loads data. Ponder what these differences are. Try changing a
               pipeline that uses one into a pipeline that uses the other.</li>
            <li>Similarly, there is a difference between a <code>p:output</code> configuration for a pipeline, and a
                  <code>p:store</code> step executed by that pipeline. Consider this difference and how we might define
               a rule for when to prefer one or the other. How is the pipeline used - is it called directly, or intended
               for use as a step in other pipelines? How is it to be controlled at runtime?</li>
            <li>Try inserting <code>p:store</code> steps into a pipeline to capture intermediate results, that is, the
               output of any step before they are processed by the next step. Such steps can aid in debugging, among
               other uses.</li>
            <li><code>@message</code> attributes on steps provide messages for the runtime traceback. They are optional
               but this repo follows a rule that any <code>p:load</code> or <code>p:store</code> should be provided with
               a message. Why?</li>
            <li>A <code>p:identity</code> step passes its input unchanged to the next step. But can also be provided
               with a <code>@message</code>.</li>
         </ul>
         <p>After breaking anything, restore it to working order. Create modified copies of any pipelines for further
            analysis and discussion.</p>
         <ul>
            <li>
               <p>Concept: copy and change one of the pipelines provided to acquire a software library or resource of
                  your choice.</p>
            </li>
         </ul>
      </section>
      <section>
         <h2>What is this XSLT?</h2>
         <p>If your criticism of XProc so far is that it makes it look easy when it isn't, you have a point.</p>
         <p>Conversion from XML to JSON isn't free, assuming it works at all.</p>
         <p>In this case, the heavy lifting is done by the XSLT component - the Saxon engine invoked by the
               <code>p:xslt</code> step, applying logic defined in an XSLT stylesheet (aka transformation) stored
            elsewhere. It happens that a converter for OSCAL data is available in XSLT, so rather than having to
            confront this considerable problem ourselves, we drop in the solution we have at hand.</p>
         <p>In later units we will see how using the XProc steps described, rudimentary data manipulations can be done
            using XProc by itself, without entailing the use of either XSLT or XQuery (another capability invoked with a
            different step).</p>
         <p>At the same time, while pipelines are based on the idea of passing data through a series of processes, there
            are many cases where logic is sufficiently complex that it becomes essential to maintain – and test – that
            logic externally from the XProc. At what point it becomes more efficient to encapsulate logic separately
            (whether by XSLT, XQuery or other means), depends very much on the case.</p>
         <p>The <code>p:xslt</code> pipeline step in particular is so important for real-world uses of XProc that it is
            introduced early, to show such a black-box application.</p>
         <p>XProc also makes a fine environment for testing XSLT developed or acquired to handle specific tasks, a topic
            covered in more depth later.</p>
         <p>Indeed XSLT and XQuery being, like XProc itself, declarative languages, it makes sense to factor them out
            while maintaining easy access and transparency for analysis and auditing purposes.</p>
      </section>
      <section>
         <h2>What could possibly go wrong?</h2>
         <p>When coping with errors, syntax errors are relatively easy. But anomalous inputs, especially invalid inputs,
            can result in lost data. (A common reason data is not valid even when it appears to be is that it has
            foreign unknown contents, or contents out of place - the kinds of things that might fail to be converted.)
            The most important concern when engineering a pipeline is to see to it that no data quality problems are
            introduced inadvertantly. While in comparison to syntax or configuration problems, data quality issues can
            be subtle, there is also good news: the very same tools we use to process inputs into outputs, can also be
            used to test and validate data to both applicable standards and local rules.</p>
         <p>Generally speaking, OSCAL maintains <q>validation parity</q> between its XML and JSON formats with respect
            to their schemas. That is to say, the XSD (XML schema) covers essentially the same set of rules for OSCAL
            XML data as the JSON Schema does for OSCAL JSON data, accounting for differences between the two notations,
            the data models and how information is mapped into them. A consequence of this is that valid OSCAL data,
            either XML or JSON, can reliably be converted to valid data in the other notation, while invalid data may
            not be converted at all, resulting in gaps or empty results.</p>
         <p>For this and related reasons on open systems, the working principle in XML is often to formalize a model
            (typically by writing and deploying a schema) as early as possible - or adopt a model already built - as a
            way to institute and enforce schema validation as a <b>prerequisite</b> and <b>primary requirement</b> for
            working with any data set. Validation against schemas is covered in a subsequent lesson unit (coming soon
            near you).</p>
         <section>
            <h3>Intercepting errors</h3>
            <p>One way to manage the problem of ensuring input quality is to validate on the way in, either as a
               dependent (prerequisite) process, or built into a pipeline. Whatever you want to do with invalid inputs,
               including ignoring them and producing warnings or runtime exceptions, can be defined in a pipeline much
               like anything else.</p>
            <p>In the <a href="../../../projects/oscal-publish/publish-oscal-catalog.xpl">publishing demonstration
                  project folder</a> is an XProc that valides XML against an OSCAL schema, before formatting it. The
               same could be done for an XProc that converts the data into JSON - either or both before or after
               conversion.</p>
            <p>Learn more about recognizing and dealing with errors in <a href="oscal-convert_102_src.html"
                  class="LessonUnit">Lesson 102</a>, or continue on to the next project, oscal-validate, for more on
               validation of documents and sets of documents.</p>
         </section>
      </section>
   </body>
</html>