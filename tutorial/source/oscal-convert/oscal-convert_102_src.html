<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>102: Hands on data conversions</title>
      <meta charset="utf-8" />
   </head>
   <body>
      <h1>102: Hands on data conversions</h1>
      <section>
         <h2>Goals</h2>
         <p>Learn how OSCAL data can be converted between JSON and XML formats, using XProc.</p>
         <p>Learn something about potential problems and limitations when doing this, and about how to detect, avoid,
            prevent or mitigate them.</p>
         <p>Work with XProc features designed for handling JSON data (XDM <b>map</b> objects that can be cast to
            XML).</p>
      </section>
      <section>
         <h2>Prerequisites</h2>
         <p>Run the pipelines described in <a href="https://github.com/usnistgov/oscal-xproc3/discussions/18">the 101
               Lesson</a></p>
      </section>
      <section>
         <h2>Resources</h2>
         <p>Same as the <a href="oscal-convert_101_src.html" class="LessonUnit">101 lesson</a>.</p>
      </section>
      <section>
         <h2>Some breaking and making</h2>
         <p>Every project you examine provides an opportunity to alter pipelines and see how they fail when not encoded
            correctly – when <q>broken</q>, any way we can think of breaking them. Then build good habits by repairing
            the damage. Experiment and observation bring learning.</p>
         <p>After reading this page, perform some more disassembly / reassembly. Here are a few ideas:</p>
         <ul>
            <li>Switch out the value of an <code>@href</code> on a <code>p:document</code> or <code>p:load</code> step.
               See what happens when the file it points to is not actually there.</li>
            <li>There is a difference between <code>p:input</code>, used to configure a pipeline in its prologue, and
                  <code>p:load</code>, a step that loads data. Ponder what these differences are. Try changing a
               pipeline that uses one into a pipeline that uses the other.</li>
            <li>Similarly, there is a difference between a <code>p:output</code> configuration for a pipeline, and a
                  <code>p:store</code> step executed by that pipeline. Consider this difference and how we might define
               a rule for when to prefer one or the other. How is the pipeline used - is it called directly, or intended
               for use as a step in other pipelines? How is it to be controlled at runtime?</li>
            <li>Try inserting <code>p:store</code> steps into a pipeline to capture intermediate results, that is, the
               output of any step before they are processed by the next step. Such steps can aid in debugging, among
               other uses.</li>
            <li><code>@message</code> attributes on steps provide messages for the runtime traceback. They are optional
               but this repo follows a rule that any <code>p:load</code> or <code>p:store</code> should be provided with
               a message. Why?</li>
            <li>A <code>p:identity</code> step passes its input unchanged to the next step. But can also be provided
               with a <code>@message</code>.</li>
         </ul>
         <p>After breaking anything, restore it to working order. Create modified copies of any pipelines for further
            analysis and discussion.</p>
         <ul>
            <li>
               <p>Concept: copy and change one of the pipelines provided to acquire a software library or resource of
                  your choice.</p>
            </li>
         </ul>
      </section>
      <section>
         <h2>Identity pipeline testbed</h2>
         <p>An identity or <q>near-identity</q> or modified-identity pipeline has its uses, including diagnostics. Since
            inputs and outputs are supposed to look the same, any changes they show between inputs and outputs can be
            revealing.</p>
         <p>They are also useful for testing features, for example features for resource acquisition and disposition.
            These are fancy ways to describe how you get data into your pipeline and then out again.</p>
         <p>Additionally, there are actually useful operations supported by a pipeline that pretends to change nothing.
            For example, it can transcode a file from one encoding to another – changing nothing in the data, but
            rewriting it into a different character set.</p>
         <p>Any reader who feels a 599 lesson would be useful covering encodings and XProc should pipe up! (Feel free to
            post an Issue, Discussion, or PR with a draft.)</p>
         <section>
            <h3>0.01 - what is a <q>document</q></h3>
            <h3>0.1 - loading documents known or determinable in advance</h3>
            <p>The XProc step <code>p:load</code> can be used to load the resource indicated into the pipeline.</p>
            <p>Watch out, since <code>p:load</code> with <code>href=''</code> – loading the resource at the location
               indicated by the empty string, <code>""</code> – will load the XProc file itself. This is conformant with
               rules for URL resolution.</p>
            <h3>0.2 - binding a document to an input port</h3>
            <h3>0.3 - loading documents dynamically on discovery with <code>p:directory-list</code></h3>
            <h3>0.4 - saving results to the file system</h3>
            <h3>0.5 - exposing results on an output port</h3>
         </section>
      </section>
      <section>
         <h2>Probing error space - data conversions</h2>
         <p>Broadly speaking, problems encountered running these conversions fall into two categories, the distinction
            being simple, namely whether a bad outcome is due to an error in the processor and its logic, or in the data
            inputs provided. The term <q>error</q> here hides a great deal. So does <q>bad outcome</q>. One type of bad
            outcome takes the form of failures at runtime - the term <q>failure</q> again leaving questions open. Other
            bad outcomes are not detectable at runtime. If inputs are bad (inconsistent with stated contracts such as
            data validation), processes can run <i>correctly</i> and deliver incorrect results: correctly representing
            inputs, in their incorrectness. Again, the term <i>correct</i> here is underspecified and underdefined,
            except in the case.</p>
         <section>
            <h3>Converting broken XML or JSON</h3>
         </section>
         <section>
            <h3>Converting broken OSCAL</h3>
         </section>
         <section>
            <h3>Converting not-OSCAL</h3>
         </section>
      </section>
      <section>
         <h2>XProc diagnostic how-to</h2>
         <section>
            <h3>Emitting runtime messages</h3>
         </section>
         <section>
            <h3>Saving out interim results</h3>
            <p><code>p:store</code></p>
         </section>
      </section>
      <section>
         <h2>Validate early and often</h2>
      </section>
      <section>
         <h2>for 599: XProc for JSON</h2>
         <p>map objects; steps for working with them; interim p:store as debug method; output ports to see results (final and intermediate) or bind them</p>
      </section>
      <section>
         <h2>for 599: YAML TODO</h2>
         <p>map objects; steps for working with them</p>
      </section>
      <section>
         <h2>for 599: XProc port bindings</h2>
         <p>This is actually a .bat or .sh exercise - write a script that invokes XProc with a binding to a runtime
            argument</p>
         <p>Thus, a script <code>convert-oscal-catalog-xml.sh mycatalog.xml</code> could produce
               <code>mycatalog.json</code> from <code>mycatalog.xml</code> etc.</p>
         <p>Such a script could live in the project directory - do we want an Issue for this work item? </p>
      </section>
      <section>
         <h2>for 599: URIs and URI schemes</h2>
         <p>see <a href="https://spec.xproc.org/master/head/xproc/#err.inline.D0012"></a> it is up to implementations to
            define supported URI schemes  - also XML catalogs</p>
      </section>
      <section>
         <h2>for 599: round tripping as process test</h2>
      </section>
   </body>
</html>