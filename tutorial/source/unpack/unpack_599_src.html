<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>599: Going deeper</title>
   </head>
   <body>
      <h1>599: Going deeper</h1>
      <p>More in depth.</p>
      <section>
         <h2>Goals</h2>
         <ul>
            <li>Consider XProc in its operational context including available <b>standards</b> and applicable
                  <b>requirements</b>, both generalized and local</li>
            <li>Learn or relearn some deep XML history including alternative approaches</li>
            <li>Inform your capability to assess the utility and appropriateness of XProc in particular and XML in
               general, for a given problem or domain</li>
         </ul>
      </section>
      <section>
         <h2>Resources</h2>
         <p>The same pipelines you ran in setup: <a href="../setup/setup_101_src.html">Setup 101</a>.</p>
         <p>Also, <a href="https://xproc.org">XProc.org dashboard page</a></p>
         <p>Also, XProc index materials produced in this repository: <a href="../../../xproc-doc/readme.md">XProc
               docs</a></p>
      </section>
      <section>
         <h2>Prerequisites</h2>
         <p>Same as <a href="../setup/setup_101_src.html">Setup 101</a>. Prior exercises, or the practical equivalent, are
            assumed.</p>
      </section>
      <section>
         <h2>XProc schema</h2>
      </section>
      <p>A schema for the XProc language, considered as core steps (compound and atomic) plus optional community-defined
         steps, is referenced from the <a href="https://spec.xproc.org/3.0/xproc/#ancillary-files">XProc
            Specification</a>. <a href="https://spec.xproc.org/3.0/xproc/xproc30.rng">This RNG schema</a> is very
         useful.</p>
      <p>It may often be considered gratuitous to validate XProc files against a schema, when the application (for us,
         Morgana)must in any case take responsibility for conformance issues, as it sees fit. The reference schema
         becomes useful if we find or suspect bugs in Morgana, but until then it need not have any direct role in any
         runtime operation.</p>
      <p>Nevertheless the RNG schema still serves as a reference and an object for querying -- queries whose results
         tell us about XProc. <a href="../../GRAB-XPROC-RESOURCES.xpl">A pipeline</a> for acquiring both RNG schema and
         its RNC (compact syntax) variant is provided for interest and possible later use.</p>
      <section>
         <h2>XPath</h2>
         <p>Like other XDM-based technologies, XProc embeds and incorporates XPath, an expression language for XML.
            XPath 3.0 is a functional language in its own right, although not designed for end-to-end processing of
            encoded source data into encoded results, but only for certain critical operations that ordinarily need to
            be performed within such end-to-end processing. Since it is partial in this way, XPath is defined not in
            terms of any data notation (such as XML syntax or any other) but rather against an <i>abstract data
               object</i>, namely an <a href="https://www.w3.org/TR/xpath-datamodel/">XDM</a> instance (XML data model),
            a putative information object that may be provided to the system by parsing an XML (syntax) instance, or by
            other means. As the query language for <a href="https://www.w3.org/TR/xpath-datamodel/">XDM</a> and the
            basis for XQuery, <a href="https://www.w3.org/TR/xpath-31/">XPath</a> is the <q>other half</q> of the data
            model, which any architect of a system using this technology must know. Learning XPath equips you mentally
            for dealing with the XDM in XQuery, XSLT, XProc or anywhere you find it.</p>
         <p>For those not already familiar with XPath, on line resources can be helpful. Keep in mind that <a
               href="https://www.w3.org/TR/xpath-31/">XPath 3.1</a> outstrips XPath 1.0 in many important respects.</p>
      
      <section>
         <h3>Documents and data</h3>
            <p>One of the more important features of XPath and the XDM is that they are designed not only to meet needs
               for the representation and transmission of structured data. A specialized class of data formats has
               evolved that represent information in ways that are not <q>unstructured</q>, but that contrast with more
               common or usual structures of data formats, whether they be tabular data, serialization formats for
               object models, or some other regular and fore-ordained arrangement. One might say <q>common</q> or
                  <q>usual</q> with reservation, since of course documents are not uncommon where they are common.</p>
            <p>We see a great deal of structured data these days if only because it is so easy to make structured data
               with machines, and we now have the machines. What remains difficult is to translate what has not been
               created by a machine, into a form that a machine can <q>recognize</q>, or rather into a form we can
               recognize in and with the machine, without destroying it.</p>
            <p>So documents are called <q>unstructured</q> but they might better be called <q>relatively irregular</q>,
               meaning not that they have no structure, but that each one is structured in itself, and is hence not
               compatible or not fully compatible with encodings designed to capture other structures.</p>
            <p>And to the extent this is the case, any encoding capable of describing documents must have the capability
               of supporting each document's own distinctive structure and organization, whether that be due to its
               family (what is called a <b>document type</b>) or an expression of its own intrinsic logic. The format
               must be not only structured, but <i>structurable</i>, and its structures must to some extent be capable
               of self-description – combining data with metadata.</p>
            <p>And this is to give no consideration to the fact that these structures can be described at <i>multiple
                  levels</i> of generality or specificity with regard to either their supposed semantics, or their
               configuration in operation.</p>
            <p>Documentary data formats especially markup formats are designed to work in this in-between space.</p>
         <p>And so we get XPath - a query syntax which permits working with an organized structure of a particular kind
               (an <i>XDM document tree</i>), which in turn is designed for handling the combination of <i>highly
                  regular</i> and <i>quite irregular</i> data structures that characterize information sets we (loosely)
               call <b>documentary</b>.</p>
         <p>A definition for what is a document is out of scope for this tutorial – an interesting topic but not only a
               technical one.</p>
      </section></section>
      <section>
         <h2>XML time line</h2>
         <p>[TODO: complete this, or move it, or both]</p>
         <table>
            <thead>
               <tr>
                  <th>Year</th>
                  <th>Publication</th>
                  <th>Capabilities</th>
                  <th>Processing frameworks</th>
                  <th>Platforms</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td>1987</td>
                  <td>SGML (ISO-IEC 8879-1)</td>
                  <td>parsing logic; schema validation; configurable syntax; tree of elements and attributes</td>
                  <td>Proprietary stacks</td>
                  <td>Mainframes, workstations</td>
               </tr>
               <tr>
                  <td>1998</td>
                  <td>XML 1.0</td>
                  <td>standard syntax</td>
                  <td>Batch processing, shell scripts, <code>make</code></td>
                  <td>Mainframes, workstations, PCs (x86 generation)</td>
               </tr>
               <tr>
                  <td>1996</td>
                  <td>Unicode 2.0</td>
                  <td>standard character sets</td>
                  <td>Support for Unicode is slow to come</td>
                  <td></td>
               </tr>
               <tr>
                  <td>1999</td>
                  <td>XPath 1.0, XSLT 1.0</td>
                  <td>basic tree querying and transformations (down hill)</td>
                  <td>Web browsers? (some, sort of)</td>
                  <td></td>
               </tr>
               <tr>
                  <td>2000</td>
                  <td></td>
                  <td></td>
                  <td>Apache Ant</td>
                  <td>Java</td>
               </tr>
               <tr>
                  <td></td>
                  <td>XQuery 1.0</td>
                  <td></td>
                  <td>Perl, Python, Java APIs / integration</td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XPath 2.0</td>
                  <td></td>
                  <td>Server frameworks (Apache Cocoon)</td>
                  <td></td>
               </tr>
               <tr>
                  <td>2003-2004</td>
                  <td>W3C Document Object Model (DOM)</td>
                  <td>API for HTML and XML documents</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2005</td>
                  <td><q>The XML data model</q> (W3C)</td>
                  <td>An essay</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2007</td>
                  <td>XSLT 2.0</td>
                  <td>transformations (up hill)</td>
                  <td>XProc 1.0</td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XDM (XPath/XQuery data model)</td>
                  <td>unification</td>
                  <td></td>
                  <td>Client- and server-side XML processing stacks</td>
               </tr>
               <tr>
                  <td></td>
                  <td>XPath 3.0</td>
                  <td></td>
                  <td>Web browsers (all - but only XPath 1.0/HTML DOM Level 4)</td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XPath 3.1</td>
                  <td>higher-order functions, map and array objects</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XProc 1.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2017</td>
                  <td>XSLT 3.0/3.1</td>
                  <td>JSON harmonization, functions as arguments</td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td></td>
                  <td>XProc 3.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
               <tr>
                  <td>2022</td>
                  <td>Unicode 15.0</td>
                  <td></td>
                  <td></td>
                  <td></td>
               </tr>
            </tbody>
         </table>
         <p>The technologies have been in constant use over this period.</p>
         <p>Historically, the requirements of processing frameworks have often been met by software developers' build
            utilities (for example, GNU <code>make</code> or Apache Ant). This is not an accident: in certain respects,
            a publishing framework can be considered as a <q>documentary build</q> at a higher level.</p>
      </section>
      <section>
         <h2>XPath illustrative examples</h2>
         <p>This is not the place to learn XPath, but a selection of XPaths can offer a hint of its capabilities.</p>
         <table>
            <thead>
               <tr>
                  <th>XPath</th>
                  <th>Returns</th>
                  <th>XPath long (explicit) notation</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td><code>/html</code></td>
                  <td>An XML document root (top-level) element named <code>html</code> (subject to namespace
                     resolution)</td>
                  <td><code>/child::html</code></td>
               </tr>
               <tr>
                  <td><code>//p</code></td>
                  <td>All the elements named <code>p</code> in the document</td>
                  <td><code>/descendant-or-self::element()/child::p</code></td>
               </tr>
               <tr>
                  <td><code>//seg[@type='null']</code></td>
                  <td>All the elements named <code>seg</code> with an attribute <code>type</code> with value
                        <code>null</code></td>
                  <td><code>/descendant-or-self::element()/child::seg[attribute::type='null']</code></td>
               </tr>
               <tr>
                  <td><code>/*</code></td>
                  <td>Any document (rather, any element at the top of a document) - <code>*</code> is a wildcard
                     character</td>
                  <td><code>/child::element()</code></td>
               </tr>
               <tr>
                  <td><code>/section[exists(.//table)]</code></td>
                  <td>An element inside the top-level element, named <code>section</code>, that contains a
                        <code>table</code> element anywhere inside it</td>
                  <td><code>/child::section[exists(self::node()/descendant-or-self::element()/child::table)]</code></td>
               </tr>
               <tr>
                  <td><code>/descendant::p[10]</code></td>
                  <td>The tenth <code>p</code> element in the document</td>
                  <td><code>/descendant::p[position() eq 10]</code></td>
               </tr>
               <tr>
                  <td><code>//p[10]</code></td>
                  <td>All <code>p</code> elements, that are the tenth <code>p</code> inside their respective
                     parents</td>
                  <td><code>/descendant-or-self::element()/child::p[position() eq 10]</code></td>
               </tr>
               <tr>
                  <td><code>//section[count(.//p) gt 10]</code></td>
                  <td>All <code>section</code> elements that contain more than 10 <code>p</code> elements, at any
                     depth</td>
                  <td><code>/child::section[count(self::node()/descendant-or-self::element()/child::p) gt
                     10]</code></td>
               </tr>
            </tbody>
         </table>
      </section>
      <section>
         <h2>XML and XDM: context and rationale</h2>
         <ul>
            <li>Standard, non-proprietary and freely available without restriction</li>
            <li>Consistently and repeatedly shown to be capable at scale (size/complexity)</li>
            <li>Supported by commodity tools, easing problem of proprietary product endorsement</li>
         </ul>
         <p>The technologies we rely on share a common foundation in XML and XDM, technologies developed under the
            auspices of the World Wide Web Consortium. </p>
         <p>They are commodity tools in the sense that they are freely available to use without restriction, an
            important qualification for this distribution, which has a prior commitment <i>not to endorse particular
               technological solutions to any problem</i>, however posed or circumscribed. Accordingly, solutions here
            are not offered as recommendations, but rather as stipulations of (minimum) viable functionality in tools or
            capabilities, and not only using tools as <q>black boxes</q>, but under control and conformant to external
            specifications – i.e., standards.</p>
         <p>Users of these tools should keep in mind the model whereby we imagine the viability of a tools market and
            ecosystem that enables both large and small software developers including independent developers, academic
            researchers, and students, to participate meaningfully, finding an appropriate value or service proposition
            to provide their long-term goals. Translated, this means the tools must be capable enough for industrial use
            at scale, while also <q>scale down</q> to demonstration or classroom use.</p>
         <p>In web standards including HTML and Javascript (ECMAScript) we arguably have the beginnings of such an
            ecosystem, while it is also contested and turbulent. Within the publishing sector more broadly and
            intersecting with the web, the XML family of standards arguably provides the best demonstration of complete
            or near-complete capabilities at least with respect to the harder problems of document processing.</p>
         <ul>
            <li>XSLT up to <a href="https://www.w3.org/TR/xslt-30/">XSLT 3.0</a> (in <a
                  href="https://www.saxonica.com/welcome/welcome.xml">Saxon</a>)</li>
            <li><a href="https://www.w3.org/TR/xquery-31/">XQuery</a> (in Saxon)</li>
            <li><a href="https://github.com/Schematron">Schematron</a> (in <a href="https://github.com/schxslt/schxslt">SchXSLT</a>, an open-source implementation
               in XSLT of <a href="https://schematron.com/">Schematron</a> including the <a
                  href="https://www.iso.org/obp/ui/#iso:std:iso-iec:19757:-3:ed-3:v1:en">ISO/IEC 19757-3</a>
               specification</li>
            <li><a href="https://github.com/xspec/xspec">XSpec</a>, a community-maintained XSLT-based framework for
               test-driven development, supporting testing XSLT, XQuery and Schematron</li>
         </ul>
         <p>Since they are known to be highly conformant to their respective specifications as well as well tested,
            these tools provide a useful functional baseline for evaluating other tooling that addresses the same
            functional requirements.</p>
         <p>They are also, relatively speaking, <i>mature</i> technologies, at least in comparison to similar
            offerings.</p>
         <p>And when XProc works, we also have the functional underpinnings we need for comparing - for example -
            different XSLT implementations.</p>
         <p>Initiated in 1996, XML continues to be generative in 2024.</p>
      </section>
      <section>
         <h2>Exercise: Discussion board</h2>
         <p>Create or contribute to a Github discussion board offering perspective or (especially!) relevant information
            or experience on any of the larger questions.</p>
      </section>
   </body>
</html>